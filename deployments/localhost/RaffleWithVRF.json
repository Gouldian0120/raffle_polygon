{
  "address": "0x36C02dA8a0983159322a80FFE9F24b1acfF8B570",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_keyHash",
          "type": "bytes32"
        },
        {
          "internalType": "uint64",
          "name": "_subscriptionId",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "_vrfCoordinator",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_usdtInterface",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_feeRecipient",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AlreadyRefunded",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DrawExpirationTimeNotReached",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC20TransferFail",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC20TransferFromFail",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ERC721TransferFromFail",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientNativeTokensSupplied",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidCaller",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidCurrency",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidFeeRecipient",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidIndex",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidPricingOption",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidPrize",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidPrizesCount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidStatus",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidWinnersCount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MaximumEntriesPerParticipantReached",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MaximumEntriesReached",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NotAContract",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "have",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "want",
          "type": "address"
        }
      ],
      "name": "OnlyCoordinatorCanFulfill",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PrizeAlreadyClaimed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RandomnessRequestAlreadyExists",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "RandomnessRequestDoesNotExist",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "currencies",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isAllowed",
          "type": "bool"
        }
      ],
      "name": "CurrenciesStatusUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "buyer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint208",
          "name": "amount",
          "type": "uint208"
        }
      ],
      "name": "EntryRefunded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "buyer",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint40",
          "name": "entriesCount",
          "type": "uint40"
        },
        {
          "indexed": false,
          "internalType": "uint208",
          "name": "price",
          "type": "uint208"
        }
      ],
      "name": "EntrySold",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint40",
          "name": "feePrice",
          "type": "uint40"
        }
      ],
      "name": "FeePriceUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "feeRecipient",
          "type": "address"
        }
      ],
      "name": "FeeRecipientUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "FeesClaimed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        }
      ],
      "name": "IncreaseRaffleId",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "winnerIndex",
          "type": "uint256[]"
        }
      ],
      "name": "PrizesClaimed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "enum IRaffleVRF.RaffleStatus",
          "name": "status",
          "type": "uint8"
        }
      ],
      "name": "RaffleStatusUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "requeestId",
          "type": "uint256"
        }
      ],
      "name": "RandomnessRequested",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "KEY_HASH",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAXIMUM_NUMBER_OF_PRIZES_PER_RAFFLE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAXIMUM_NUMBER_OF_WINNERS_PER_RAFFLE",
      "outputs": [
        {
          "internalType": "uint40",
          "name": "",
          "type": "uint40"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PRICING_OPTIONS_PER_RAFFLE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "REQUEST_CONFIRMATIONS",
      "outputs": [
        {
          "internalType": "uint16",
          "name": "",
          "type": "uint16"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SELECT_WINNERS_LIMIT",
      "outputs": [
        {
          "internalType": "uint40",
          "name": "",
          "type": "uint40"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SUBSCRIPTION_ID",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "USDTInterface",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "VRF_COORDINATOR",
      "outputs": [
        {
          "internalType": "contract VRFCoordinatorV2Interface",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        }
      ],
      "name": "claimFees",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bool",
              "name": "isMinimumEntriesFixed",
              "type": "bool"
            },
            {
              "internalType": "uint40",
              "name": "minimumEntries",
              "type": "uint40"
            },
            {
              "internalType": "uint40",
              "name": "maximumEntriesPerParticipant",
              "type": "uint40"
            },
            {
              "components": [
                {
                  "internalType": "uint40",
                  "name": "winnersCount",
                  "type": "uint40"
                },
                {
                  "internalType": "uint40",
                  "name": "cumulativeWinnersCount",
                  "type": "uint40"
                },
                {
                  "internalType": "enum IRaffleVRF.TokenType",
                  "name": "prizeType",
                  "type": "uint8"
                },
                {
                  "internalType": "uint8",
                  "name": "prizeTier",
                  "type": "uint8"
                },
                {
                  "internalType": "address",
                  "name": "prizeAddress",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "prizeId",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "prizeAmount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IRaffleVRF.Prize[]",
              "name": "prizes",
              "type": "tuple[]"
            },
            {
              "components": [
                {
                  "internalType": "uint40",
                  "name": "entriesCount",
                  "type": "uint40"
                },
                {
                  "internalType": "uint208",
                  "name": "price",
                  "type": "uint208"
                }
              ],
              "internalType": "struct IRaffleVRF.PricingOption[5]",
              "name": "pricingOptions",
              "type": "tuple[5]"
            }
          ],
          "internalType": "struct IRaffleVRF.CreateRaffleCalldata",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "createRaffle",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "raffleId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pricingOptionIndex",
              "type": "uint256"
            }
          ],
          "internalType": "struct IRaffleVRF.EntryCalldata[]",
          "name": "entries",
          "type": "tuple[]"
        }
      ],
      "name": "enterRaffles",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feePrice",
      "outputs": [
        {
          "internalType": "uint40",
          "name": "",
          "type": "uint40"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "feeRecipient",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        }
      ],
      "name": "getEntries",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint40",
              "name": "currentEntryIndex",
              "type": "uint40"
            },
            {
              "internalType": "address",
              "name": "participant",
              "type": "address"
            }
          ],
          "internalType": "struct IRaffleVRF.Entry[]",
          "name": "entries",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getLatestRequestId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        }
      ],
      "name": "getPricingOptions",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint40",
              "name": "entriesCount",
              "type": "uint40"
            },
            {
              "internalType": "uint208",
              "name": "price",
              "type": "uint208"
            }
          ],
          "internalType": "struct IRaffleVRF.PricingOption[5]",
          "name": "pricingOptions",
          "type": "tuple[5]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        }
      ],
      "name": "getPrizes",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint40",
              "name": "winnersCount",
              "type": "uint40"
            },
            {
              "internalType": "uint40",
              "name": "cumulativeWinnersCount",
              "type": "uint40"
            },
            {
              "internalType": "enum IRaffleVRF.TokenType",
              "name": "prizeType",
              "type": "uint8"
            },
            {
              "internalType": "uint8",
              "name": "prizeTier",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "prizeAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "prizeId",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "prizeAmount",
              "type": "uint256"
            }
          ],
          "internalType": "struct IRaffleVRF.Prize[]",
          "name": "prizes",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        }
      ],
      "name": "getWinners",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "participant",
              "type": "address"
            },
            {
              "internalType": "bool",
              "name": "claimed",
              "type": "bool"
            },
            {
              "internalType": "uint8",
              "name": "prizeIndex",
              "type": "uint8"
            },
            {
              "internalType": "uint40",
              "name": "entryIndex",
              "type": "uint40"
            }
          ],
          "internalType": "struct IRaffleVRF.Winner[]",
          "name": "winners",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        }
      ],
      "name": "getWinnersCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "winnersCount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "isCurrencyAllowed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "raffles",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "enum IRaffleVRF.RaffleStatus",
          "name": "status",
          "type": "uint8"
        },
        {
          "internalType": "bool",
          "name": "isMinimumEntriesFixed",
          "type": "bool"
        },
        {
          "internalType": "uint40",
          "name": "drawnAt",
          "type": "uint40"
        },
        {
          "internalType": "uint40",
          "name": "minimumEntries",
          "type": "uint40"
        },
        {
          "internalType": "uint40",
          "name": "maximumEntriesPerParticipant",
          "type": "uint40"
        },
        {
          "internalType": "uint208",
          "name": "claimableFees",
          "type": "uint208"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rafflesCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "rafflesParticipantsStats",
      "outputs": [
        {
          "internalType": "uint208",
          "name": "amountPaid",
          "type": "uint208"
        },
        {
          "internalType": "uint40",
          "name": "entriesCount",
          "type": "uint40"
        },
        {
          "internalType": "bool",
          "name": "refunded",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "randomnessRequests",
      "outputs": [
        {
          "internalType": "bool",
          "name": "exists",
          "type": "bool"
        },
        {
          "internalType": "uint248",
          "name": "randomWord",
          "type": "uint248"
        },
        {
          "internalType": "uint256",
          "name": "raffleId",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        },
        {
          "internalType": "uint256[]",
          "name": "randomWords",
          "type": "uint256[]"
        }
      ],
      "name": "rawFulfillRandomWords",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requestId",
          "type": "uint256"
        }
      ],
      "name": "selectWinners",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint40",
          "name": "_feePrice",
          "type": "uint40"
        }
      ],
      "name": "setFeePrice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_feeRecipient",
          "type": "address"
        }
      ],
      "name": "setFeeRecipient",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "currencies",
          "type": "address[]"
        },
        {
          "internalType": "bool",
          "name": "isAllowed",
          "type": "bool"
        }
      ],
      "name": "updateCurrenciesStatus",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xca3ec3fa599d3ad4974d4905ea09460720929da64abf7192ce6b16c61864cc0d",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x36C02dA8a0983159322a80FFE9F24b1acfF8B570",
    "transactionIndex": 0,
    "gasUsed": "2955225",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000020000000000000100000800000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000001000000000000200000000000000000000000002000000000000000000020000000000000000000000000000000000000000000080000000000002000000000",
    "blockHash": "0x059e52e95ce3dee767acc8f2fb7dd187f7111b27ea6010ffdfe6dd887df20e12",
    "transactionHash": "0xca3ec3fa599d3ad4974d4905ea09460720929da64abf7192ce6b16c61864cc0d",
    "logs": [
      {
        "transactionIndex": 0,
        "blockNumber": 1909602,
        "transactionHash": "0xca3ec3fa599d3ad4974d4905ea09460720929da64abf7192ce6b16c61864cc0d",
        "address": "0x36C02dA8a0983159322a80FFE9F24b1acfF8B570",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0x059e52e95ce3dee767acc8f2fb7dd187f7111b27ea6010ffdfe6dd887df20e12"
      },
      {
        "transactionIndex": 0,
        "blockNumber": 1909602,
        "transactionHash": "0xca3ec3fa599d3ad4974d4905ea09460720929da64abf7192ce6b16c61864cc0d",
        "address": "0x36C02dA8a0983159322a80FFE9F24b1acfF8B570",
        "topics": [
          "0x7a7b5a0a132f9e0581eb8527f66eae9ee89c2a3e79d4ac7e41a1f1f4d48a7fc2"
        ],
        "data": "0x000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb92266",
        "logIndex": 1,
        "blockHash": "0x059e52e95ce3dee767acc8f2fb7dd187f7111b27ea6010ffdfe6dd887df20e12"
      }
    ],
    "blockNumber": 1909602,
    "cumulativeGasUsed": "2955225",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f",
    "1",
    "0x4826533B4897376654Bb4d4AD88B7faFD0C98528",
    "0x99bbA657f2BbC93c02D617f8bA121cB8Fc104Acf",
    "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
  ],
  "numDeployments": 1,
  "solcInputHash": "5d8abf935c2b13d38b3394f94599e9b1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"_subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdtInterface\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyRefunded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DrawExpirationTimeNotReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20TransferFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC20TransferFromFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ERC721TransferFromFail\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientNativeTokensSupplied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCurrency\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFeeRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPricingOption\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrize\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrizesCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStatus\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidWinnersCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaximumEntriesPerParticipantReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaximumEntriesReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrizeAlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RandomnessRequestAlreadyExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RandomnessRequestDoesNotExist\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"currencies\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"name\":\"CurrenciesStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint208\",\"name\":\"amount\",\"type\":\"uint208\"}],\"name\":\"EntryRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"entriesCount\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint208\",\"name\":\"price\",\"type\":\"uint208\"}],\"name\":\"EntrySold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"feePrice\",\"type\":\"uint40\"}],\"name\":\"FeePriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"}],\"name\":\"FeeRecipientUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"IncreaseRaffleId\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"winnerIndex\",\"type\":\"uint256[]\"}],\"name\":\"PrizesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum IRaffleVRF.RaffleStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"RaffleStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requeestId\",\"type\":\"uint256\"}],\"name\":\"RandomnessRequested\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"KEY_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_NUMBER_OF_PRIZES_PER_RAFFLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_NUMBER_OF_WINNERS_PER_RAFFLE\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICING_OPTIONS_PER_RAFFLE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REQUEST_CONFIRMATIONS\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SELECT_WINNERS_LIMIT\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUBSCRIPTION_ID\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTInterface\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VRF_COORDINATOR\",\"outputs\":[{\"internalType\":\"contract VRFCoordinatorV2Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isMinimumEntriesFixed\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"minimumEntries\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"maximumEntriesPerParticipant\",\"type\":\"uint40\"},{\"components\":[{\"internalType\":\"uint40\",\"name\":\"winnersCount\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"cumulativeWinnersCount\",\"type\":\"uint40\"},{\"internalType\":\"enum IRaffleVRF.TokenType\",\"name\":\"prizeType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"prizeTier\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"prizeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prizeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prizeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IRaffleVRF.Prize[]\",\"name\":\"prizes\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint40\",\"name\":\"entriesCount\",\"type\":\"uint40\"},{\"internalType\":\"uint208\",\"name\":\"price\",\"type\":\"uint208\"}],\"internalType\":\"struct IRaffleVRF.PricingOption[5]\",\"name\":\"pricingOptions\",\"type\":\"tuple[5]\"}],\"internalType\":\"struct IRaffleVRF.CreateRaffleCalldata\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"createRaffle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricingOptionIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct IRaffleVRF.EntryCalldata[]\",\"name\":\"entries\",\"type\":\"tuple[]\"}],\"name\":\"enterRaffles\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePrice\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"getEntries\",\"outputs\":[{\"components\":[{\"internalType\":\"uint40\",\"name\":\"currentEntryIndex\",\"type\":\"uint40\"},{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"}],\"internalType\":\"struct IRaffleVRF.Entry[]\",\"name\":\"entries\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"getPricingOptions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint40\",\"name\":\"entriesCount\",\"type\":\"uint40\"},{\"internalType\":\"uint208\",\"name\":\"price\",\"type\":\"uint208\"}],\"internalType\":\"struct IRaffleVRF.PricingOption[5]\",\"name\":\"pricingOptions\",\"type\":\"tuple[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"getPrizes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint40\",\"name\":\"winnersCount\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"cumulativeWinnersCount\",\"type\":\"uint40\"},{\"internalType\":\"enum IRaffleVRF.TokenType\",\"name\":\"prizeType\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"prizeTier\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"prizeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prizeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prizeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IRaffleVRF.Prize[]\",\"name\":\"prizes\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"getWinners\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"prizeIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"entryIndex\",\"type\":\"uint40\"}],\"internalType\":\"struct IRaffleVRF.Winner[]\",\"name\":\"winners\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"name\":\"getWinnersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"winnersCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCurrencyAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"raffles\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"enum IRaffleVRF.RaffleStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isMinimumEntriesFixed\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"drawnAt\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"minimumEntries\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"maximumEntriesPerParticipant\",\"type\":\"uint40\"},{\"internalType\":\"uint208\",\"name\":\"claimableFees\",\"type\":\"uint208\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rafflesCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rafflesParticipantsStats\",\"outputs\":[{\"internalType\":\"uint208\",\"name\":\"amountPaid\",\"type\":\"uint208\"},{\"internalType\":\"uint40\",\"name\":\"entriesCount\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"refunded\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"randomnessRequests\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint248\",\"name\":\"randomWord\",\"type\":\"uint248\"},{\"internalType\":\"uint256\",\"name\":\"raffleId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"selectWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_feePrice\",\"type\":\"uint40\"}],\"name\":\"setFeePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"currencies\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isAllowed\",\"type\":\"bool\"}],\"name\":\"updateCurrenciesStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"claimFees(uint256)\":{\"params\":{\"raffleId\":\"The id of the raffle.\"}},\"constructor\":{\"params\":{\"_feeRecipient\":\"The recipient of the fees\",\"_usdtInterface\":\"The USDT address\"}},\"createRaffle((bool,uint40,uint40,(uint40,uint40,uint8,uint8,address,uint256,uint256)[],(uint40,uint208)[5]))\":{\"params\":{\"params\":\"The parameters of the raffle.\"},\"returns\":{\"raffleId\":\"The id of the newly created raffle.\"}},\"enterRaffles((uint256,uint256)[])\":{\"params\":{\"entries\":\"The entries to be made.\"}},\"getEntries(uint256)\":{\"params\":{\"raffleId\":\"The id of the raffle.\"},\"returns\":{\"entries\":\"The entries entered for the raffle.\"}},\"getPricingOptions(uint256)\":{\"params\":{\"raffleId\":\"The id of the raffle.\"},\"returns\":{\"pricingOptions\":\"The pricing options for the raffle.\"}},\"getPrizes(uint256)\":{\"params\":{\"raffleId\":\"The id of the raffle.\"},\"returns\":{\"prizes\":\"The prizes to be distributed.\"}},\"getWinners(uint256)\":{\"params\":{\"raffleId\":\"The id of the raffle.\"},\"returns\":{\"winners\":\"The winners of the raffle.\"}},\"getWinnersCount(uint256)\":{\"params\":{\"raffleId\":\"The id of the raffle.\"},\"returns\":{\"winnersCount\":\"The count of winners.\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"selectWinners(uint256)\":{\"params\":{\"requestId\":\"The request id returned by Chainlink.\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"updateCurrenciesStatus(address[],bool)\":{\"details\":\"Only callable by owner.\",\"params\":{\"currencies\":\"Currency addresses (address(0) for ETH)\",\"isAllowed\":\"Whether the currencies should be allowed for trading\"}}},\"stateVariables\":{\"raffles\":{\"details\":\"The key is the raffle ID.\"},\"randomnessRequests\":{\"details\":\"The key is the request ID returned by Chainlink.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"KEY_HASH()\":{\"notice\":\"The key hash of the Chainlink VRF.\"},\"MAXIMUM_NUMBER_OF_PRIZES_PER_RAFFLE()\":{\"notice\":\"The maximum number of prizes per raffle.         Each individual ERC-721 counts as one prize.         Each ETH/ERC-20 with winnersCount > 1 counts as one prize.\"},\"MAXIMUM_NUMBER_OF_WINNERS_PER_RAFFLE()\":{\"notice\":\"The maximum number of winners per raffle.\"},\"PRICING_OPTIONS_PER_RAFFLE()\":{\"notice\":\"The number of pricing options per raffle.\"},\"REQUEST_CONFIRMATIONS()\":{\"notice\":\"A Chainlink node should wait for 3 confirmations before responding.\"},\"SUBSCRIPTION_ID()\":{\"notice\":\"The subscription ID of the Chainlink VRF.\"},\"VRF_COORDINATOR()\":{\"notice\":\"The Chainlink VRF coordinator.\"},\"claimFees(uint256)\":{\"notice\":\"Claims the fees collected for a raffle.\"},\"createRaffle((bool,uint40,uint40,(uint40,uint40,uint8,uint8,address,uint256,uint256)[],(uint40,uint208)[5]))\":{\"notice\":\"Creates a new raffle.\"},\"enterRaffles((uint256,uint256)[])\":{\"notice\":\"Enters a raffle or multiple raffles.\"},\"feeRecipient()\":{\"notice\":\"The fee recipient.\"},\"getEntries(uint256)\":{\"notice\":\"Gets the entries for a raffle.\"},\"getPricingOptions(uint256)\":{\"notice\":\"Gets the pricing options for a raffle.\"},\"getPrizes(uint256)\":{\"notice\":\"Gets the prizes for a raffle.\"},\"getWinners(uint256)\":{\"notice\":\"Gets the winners for a raffle.\"},\"getWinnersCount(uint256)\":{\"notice\":\"Get count of winners.\"},\"isCurrencyAllowed(address)\":{\"notice\":\"It checks whether the currency is allowed.\"},\"raffles(uint256)\":{\"notice\":\"The raffles created.\"},\"rafflesCount()\":{\"notice\":\"The number of raffles created.\"},\"randomnessRequests(uint256)\":{\"notice\":\"The randomness requests.\"},\"selectWinners(uint256)\":{\"notice\":\"Select the winners for a raffle based on the random words returned by Chainlink.\"},\"updateCurrenciesStatus(address[],bool)\":{\"notice\":\"This function allows the owner to update currency statuses.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/RaffleVRF.sol\":\"RaffleWithVRF\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\",\"keccak256\":\"0x3d709a5e0f1f9b8841172b10ba8af785dd51a13eda9fc395723a706e51329904\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x54cdc97717cbae1a51a5500c8ee4875ebf056c95b54d2155a9544a79cb4f4494\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"contracts/RaffleVRF.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"./interfaces/IRaffleVRF.sol\\\";\\nimport \\\"./interfaces/generic/IERC20.sol\\\";\\nimport \\\"./libraries/Arrays.sol\\\";\\nimport \\\"./libraries/Ownable.sol\\\";\\nimport \\\"./libraries/ReentrancyGuard.sol\\\";\\n\\nimport { VRFConsumerBaseV2 } from \\\"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\\\";\\nimport { VRFCoordinatorV2Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\ncontract RaffleWithVRF is IRaffleVRF, VRFConsumerBaseV2, Ownable, ReentrancyGuard {\\n\\tusing Arrays for uint256[];\\n\\n    IERC20 public USDTInterface;\\n\\n    /**\\n     * @notice The number of raffles created.\\n     */\\n    uint256 public rafflesCount;\\n\\n    /**\\n     * @notice The raffles created.\\n     * @dev The key is the raffle ID.\\n     */\\n    mapping(uint256 => Raffle) public raffles;\\n\\n    mapping(uint256 => mapping(address => ParticipantStats)) public rafflesParticipantsStats;\\n\\n    /**\\n     * @notice It checks whether the currency is allowed.\\n     */\\n    mapping(address => bool) public isCurrencyAllowed;\\n\\n    /**\\n     * @notice The maximum number of prizes per raffle.\\n     *         Each individual ERC-721 counts as one prize.\\n     *         Each ETH/ERC-20 with winnersCount > 1 counts as one prize.\\n     */\\n    uint256 public constant MAXIMUM_NUMBER_OF_PRIZES_PER_RAFFLE = 20;\\n\\n    /**\\n     * @notice The maximum number of winners per raffle.\\n     */\\n    uint40 public constant MAXIMUM_NUMBER_OF_WINNERS_PER_RAFFLE = 2500;\\n\\n    uint40 public constant SELECT_WINNERS_LIMIT = 1000;\\n\\n    /**\\n     * @notice The fee recipient.\\n     */\\n    address public feeRecipient;\\n\\n    uint40 public feePrice = 5e4; // fee is $0.05\\n\\n    /**\\n     * @notice The number of pricing options per raffle.\\n     */\\n    uint256 public constant PRICING_OPTIONS_PER_RAFFLE = 5;\\n\\n    /**\\n     * @notice A Chainlink node should wait for 3 confirmations before responding.\\n     */\\n    uint16 public constant REQUEST_CONFIRMATIONS = 3;\\n\\n    /**\\n     * @notice The key hash of the Chainlink VRF.\\n     */\\n    bytes32 public immutable KEY_HASH;\\n\\n    /**\\n     * @notice The subscription ID of the Chainlink VRF.\\n     */\\n    uint64 public immutable SUBSCRIPTION_ID;\\n\\n    /**\\n     * @notice The Chainlink VRF coordinator.\\n     */\\n    VRFCoordinatorV2Interface public immutable VRF_COORDINATOR;\\n\\n    /**\\n     * @notice The randomness requests.\\n     * @dev The key is the request ID returned by Chainlink.\\n     */\\n    mapping(uint256 => RandomnessRequest) public randomnessRequests;\\n\\n    uint256 private latestRequestId;\\n\\n    /**\\n     * @param _feeRecipient The recipient of the fees\\n     * @param _usdtInterface The USDT address\\n     */\\n    constructor( \\n        bytes32 _keyHash,\\n        uint64 _subscriptionId,\\n        address _vrfCoordinator,\\n        address _usdtInterface, \\n        address _feeRecipient\\n    ) VRFConsumerBaseV2(_vrfCoordinator) {\\n        require(_usdtInterface != address(0), \\\"Zero USDT Interface Address\\\");\\n\\n        if(_feeRecipient == address(0)) {\\n            _setFeeRecipient(msg.sender);\\n        } else {\\n            _setFeeRecipient(_feeRecipient);\\n        }\\n\\n        KEY_HASH = _keyHash;\\n        VRF_COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);\\n        SUBSCRIPTION_ID = _subscriptionId;\\n        USDTInterface = IERC20(_usdtInterface);\\n    }\\n\\n    function createRaffle(CreateRaffleCalldata calldata params) external onlyOwner returns(uint256 raffleId) {\\n        raffleId = ++rafflesCount;\\n\\n        uint256 prizesCount = params.prizes.length;\\n        if (prizesCount == 0 || prizesCount > MAXIMUM_NUMBER_OF_PRIZES_PER_RAFFLE) {\\n            revert InvalidPrizesCount();\\n        }\\n\\n        Raffle storage raffle = raffles[raffleId];\\n\\n        uint40 cumulativeWinnersCount;\\n\\t\\tuint8 currentPrizeTier;\\n\\t\\tfor(uint256 i = 0; i < prizesCount; i ++) {\\n\\t\\t\\tPrize memory prize = params.prizes[i];\\n\\n\\t\\t\\tif(prize.prizeTier < currentPrizeTier) {\\n\\t\\t\\t\\trevert InvalidPrize();\\n\\t\\t\\t}\\n\\t\\t\\t_validatePrize(prize);\\n\\n\\t\\t\\tcumulativeWinnersCount += prize.winnersCount;\\n\\t\\t\\tprize.cumulativeWinnersCount = cumulativeWinnersCount;\\n\\t\\t\\tcurrentPrizeTier = prize.prizeTier;\\n\\n\\t\\t\\traffle.prizes.push(prize);\\n\\t\\t}\\n\\n\\t\\tuint40 minimumEntries = params.minimumEntries;\\n\\t\\tif (cumulativeWinnersCount > minimumEntries || cumulativeWinnersCount > MAXIMUM_NUMBER_OF_WINNERS_PER_RAFFLE) {\\n            revert InvalidWinnersCount();\\n        }\\n\\n        _validateAndSetPricingOptions(raffleId, params.pricingOptions);\\n\\n        raffle.owner = msg.sender;\\n        raffle.isMinimumEntriesFixed = params.isMinimumEntriesFixed;\\n        raffle.minimumEntries = minimumEntries;\\n        raffle.maximumEntriesPerParticipant = params.maximumEntriesPerParticipant;\\n\\n        _setRaffleStatus(raffle, raffleId, RaffleStatus.Open);\\n    }\\n\\n    function enterRaffles(EntryCalldata[] calldata entries) external payable nonReentrant {\\n    \\tuint256 entriesCount = entries.length;\\n    \\tuint208 expectedUSDTValue;\\n    \\tuint256 userUSDTBalance = USDTInterface.allowance(msg.sender, address(this));\\n\\n    \\tfor (uint256 i = 0; i < entriesCount; i ++) {\\n    \\t\\tEntryCalldata calldata entry = entries[i];\\n\\n    \\t\\tif (entry.pricingOptionIndex >= PRICING_OPTIONS_PER_RAFFLE) {\\n          revert InvalidIndex();\\n        }\\n\\n        uint256 raffleId = entry.raffleId;\\n        Raffle storage raffle = raffles[raffleId];\\n\\n        _validateRaffleStatus(raffle, RaffleStatus.Open);\\n\\n        PricingOption memory pricingOption = raffle.pricingOptions[entry.pricingOptionIndex];\\n\\n        uint40 newParticipantEntriesCount = rafflesParticipantsStats[raffleId][msg.sender].entriesCount + pricingOption.entriesCount;\\n        if (newParticipantEntriesCount > raffle.maximumEntriesPerParticipant) {\\n            revert MaximumEntriesPerParticipantReached();\\n        }\\n        rafflesParticipantsStats[raffleId][msg.sender].entriesCount = newParticipantEntriesCount;\\n\\n        uint208 price = pricingOption.price;\\n        expectedUSDTValue += price;\\n\\n        console.log('expectedUSDTValue', expectedUSDTValue);\\n        console.log('userUSDTBalance', userUSDTBalance);\\n        if (expectedUSDTValue > userUSDTBalance) {\\n          revert(string(\\\"Insufficient balance\\\"));\\n        }\\n        \\n        uint40 currentEntryIndex;\\n        uint256 raffleEntriesCount = raffle.entries.length;\\n        if (raffleEntriesCount == 0) {\\n            currentEntryIndex = uint40(pricingOption.entriesCount - 1);\\n        } else {\\n            currentEntryIndex = raffle.entries[raffleEntriesCount - 1].currentEntryIndex + pricingOption.entriesCount;\\n        }\\n\\n        if (raffle.isMinimumEntriesFixed) {\\n            if (currentEntryIndex >= raffle.minimumEntries) {\\n                revert MaximumEntriesReached();\\n            }\\n        }\\n\\n        raffle.entries.push(Entry({currentEntryIndex: currentEntryIndex, participant: msg.sender}));\\n        raffle.claimableFees += price;\\n\\n        rafflesParticipantsStats[raffleId][msg.sender].amountPaid += price;\\n\\n        emit EntrySold(raffleId, msg.sender, pricingOption.entriesCount, price);\\n\\n        if (currentEntryIndex >= (raffle.minimumEntries - 1)) {\\n            _drawWinners(raffleId, raffle);\\n        }\\n    \\t}\\n\\n    \\tUSDTInterface.transferFrom(msg.sender, address(this), expectedUSDTValue);\\n    }\\n\\n    /**\\n     * @param _requestId The ID of the request\\n     * @param _randomWords The random words returned by Chainlink\\n     */\\n    function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal override {\\n        if (randomnessRequests[_requestId].exists && latestRequestId == _requestId) {\\n            uint256 raffleId = randomnessRequests[_requestId].raffleId;\\n            Raffle storage raffle = raffles[raffleId];\\n\\n            if (raffle.status == RaffleStatus.Drawing) {\\n                _setRaffleStatus(raffle, raffleId, RaffleStatus.RandomnessFulfilled);\\n                // We ignore the most significant byte to pack the random word with `exists`\\n                randomnessRequests[_requestId].randomWord = uint248(_randomWords[0]);\\n            }\\n        }\\n    }\\n\\n    function selectWinners(uint256 requestId) external {\\n        RandomnessRequest memory randomnessRequest = randomnessRequests[requestId];\\n        if(!randomnessRequest.exists) {\\n            revert RandomnessRequestDoesNotExist();\\n        }\\n\\n        uint256 raffleId = randomnessRequest.raffleId;\\n\\t\\tRaffle storage raffle = raffles[raffleId];\\n\\t\\t_validateRaffleStatus(raffle, RaffleStatus.RandomnessFulfilled);\\n\\n        address raffleOwner = raffle.owner;\\n        if(msg.sender != raffleOwner) {\\n            _validateCaller(owner());\\n        }\\n\\n\\t\\tPrize[] storage prizes = raffle.prizes;\\n\\t\\tuint256 prizesCount = prizes.length;\\n\\t\\tuint256 winnersCount = prizes[prizesCount - 1].cumulativeWinnersCount;\\n\\n\\t\\tEntry[] memory entries = raffle.entries;\\n\\t\\tuint256 entriesCount = entries.length;\\n\\t\\tuint256 currentEntryIndex = uint256(entries[entriesCount - 1].currentEntryIndex);\\n        \\n        uint256[] memory currentEntryIndexArray = new uint256[](entriesCount);\\n\\t\\tfor (uint256 i = 0 ; i < entriesCount ; i ++) {\\n            currentEntryIndexArray[i] = entries[i].currentEntryIndex;\\n        }\\n\\n        uint256[] memory cumulativeWinnersCountArray = new uint256[](prizesCount);\\n        for (uint256 i = 0 ; i < prizesCount; i ++) {\\n            cumulativeWinnersCountArray[i] = prizes[i].cumulativeWinnersCount;\\n        }\\n\\n        uint256 randomWord = randomnessRequest.randomWord;\\n\\n\\t\\tfor(uint256 i; i < winnersCount; i ++) {\\n      uint256 winningEntry = randomWord % (currentEntryIndex + 1);\\n\\t\\t\\traffle.winners.push(\\n\\t\\t\\t\\tWinner({\\n\\t\\t\\t\\t\\tparticipant: entries[currentEntryIndexArray.findUpperBound(winningEntry)].participant,\\n\\t\\t\\t\\t\\tclaimed: false,\\n\\t\\t\\t\\t\\tprizeIndex: uint8(cumulativeWinnersCountArray.findUpperBound(i + 1)),\\n\\t\\t\\t\\t\\tentryIndex: uint40(winningEntry)\\n\\t\\t\\t\\t})\\n\\t\\t\\t);\\n\\t\\t}\\n\\n\\t\\t_setRaffleStatus(raffle, raffleId, RaffleStatus.Drawn);\\n    }\\n\\n    function claimFees(uint256 raffleId) external nonReentrant() {\\n        Raffle storage raffle = raffles[raffleId];\\n        _validateRaffleStatus(raffle, RaffleStatus.Drawn);\\n\\n        address raffleOwner = raffle.owner;\\n        if(msg.sender != raffleOwner) {\\n            _validateCaller(owner());\\n        }\\n\\n        Entry[] memory entries = raffle.entries;\\n\\t\\tuint256 entriesCount = entries.length;\\n\\t\\tuint256 currentEntryIndex = uint256(entries[entriesCount - 1].currentEntryIndex);\\n\\n        uint256 cliamableFee = raffle.claimableFees;\\n        uint256 protocolFees = feePrice * (currentEntryIndex + 1);\\n\\n        require(USDTInterface.approve(address(this), cliamableFee), \\\"USDT approve failed\\\");\\n\\n        cliamableFee = cliamableFee - protocolFees;\\n\\n        USDTInterface.transferFrom(address(this), feeRecipient, protocolFees);\\n        USDTInterface.transferFrom(address(this), msg.sender, cliamableFee);\\n\\n        raffle.claimableFees = 0;\\n\\n        _setRaffleStatus(raffle, raffleId, RaffleStatus.Complete);\\n\\n        emit FeesClaimed(raffleId, protocolFees + cliamableFee);\\n    }\\n\\n    function updateCurrenciesStatus(address[] calldata currencies, bool isAllowed) external onlyOwner {\\n        uint256 count = currencies.length;\\n        for (uint256 i = 0 ; i < count; i ++) {\\n            isCurrencyAllowed[currencies[i]] = isAllowed;\\n        }\\n        emit CurrenciesStatusUpdated(currencies, isAllowed);\\n    }\\n    \\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\\n        _setFeeRecipient(_feeRecipient);\\n    }\\n\\n    function setFeePrice(uint40 _feePrice) external onlyOwner {\\n        _setFeePrice(_feePrice);\\n    }\\n\\n    function getWinners(uint256 raffleId) external view returns (Winner[] memory winners) {\\n        winners = raffles[raffleId].winners;\\n    }\\n\\n    function getPrizes(uint256 raffleId) external view returns (Prize[] memory prizes) {\\n        prizes = raffles[raffleId].prizes;\\n    }\\n\\n    function getEntries(uint256 raffleId) external view returns (Entry[] memory entries) {\\n        entries = raffles[raffleId].entries;\\n    }\\n\\n    function getPricingOptions(uint256 raffleId) external view returns (PricingOption[PRICING_OPTIONS_PER_RAFFLE] memory pricingOptions) {\\n        pricingOptions = raffles[raffleId].pricingOptions;\\n    }\\n\\n    function getLatestRequestId() external view returns (uint256) {\\n      return latestRequestId;\\n    }\\n\\n    function getWinnersCount(uint256 raffleId) external view returns (uint256 winnersCount) {\\n        require(raffleId > 0 && raffleId <= rafflesCount, \\\"Invalid raffle ID\\\");\\n\\n        Raffle memory raffle = raffles[raffleId];\\n        Prize[] memory prizes = raffle.prizes;\\n\\t\\tuint256 prizesCount = prizes.length;\\n\\t\\twinnersCount = prizes[prizesCount - 1].cumulativeWinnersCount;\\n    }\\n\\n    /**\\n     * @param raffleId The ID of the raffle to draw winners for.\\n     * @param raffle The raffle to draw winners for.\\n     */\\n    function _drawWinners(uint256 raffleId, Raffle storage raffle) private {\\n        _setRaffleStatus(raffle, raffleId, RaffleStatus.Drawing);\\n        raffle.drawnAt = uint40(block.timestamp);\\n\\n        uint256 requestId = VRF_COORDINATOR.requestRandomWords(\\n            KEY_HASH,\\n            SUBSCRIPTION_ID,\\n            REQUEST_CONFIRMATIONS,\\n            uint32(500_000),\\n            uint32(1)\\n        );\\n\\n        latestRequestId = requestId;\\n\\n        if (randomnessRequests[requestId].exists) {\\n            revert RandomnessRequestAlreadyExists();\\n        }\\n\\n        randomnessRequests[requestId].exists = true;\\n        randomnessRequests[requestId].raffleId = raffleId;\\n\\n        emit RandomnessRequested(raffleId, requestId);\\n    }\\n\\n    /**\\n     * @param raffleId The ID of the raffle.\\n     * @param pricingOptions The pricing options for the raffle.\\n     */\\n    function _validateAndSetPricingOptions(uint256 raffleId, PricingOption[PRICING_OPTIONS_PER_RAFFLE] calldata pricingOptions) private {\\n        for (uint256 i = 0 ; i < PRICING_OPTIONS_PER_RAFFLE; i ++) {\\n            PricingOption memory pricingOption = pricingOptions[i];\\n\\n            uint40 entriesCount = pricingOption.entriesCount;\\n            uint208 price = pricingOption.price;\\n\\n            if (entriesCount == 0 || price == 0) {\\n                revert InvalidPricingOption();\\n            }\\n\\n            raffles[raffleId].pricingOptions[i] = pricingOption;\\n        }\\n    }\\n\\n    /**\\n     * @param prize The prize.\\n     */\\n    function _validatePrize(Prize memory prize) private view {\\n        if (prize.prizeType == TokenType.ERC721) {\\n            if (prize.prizeAmount != 1 || prize.winnersCount != 1) {\\n                revert InvalidPrize();\\n            }\\n        } else {\\n            if (prize.prizeType == TokenType.ERC20) {\\n                if (!isCurrencyAllowed[prize.prizeAddress]) {\\n                    revert InvalidCurrency();\\n                }\\n            }\\n\\n            if (prize.prizeAmount == 0 || prize.winnersCount == 0) {\\n                revert InvalidPrize();\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @param raffle The raffle to check the status of.\\n     * @param status The expected status of the raffle\\n     */\\n    function _validateRaffleStatus(Raffle storage raffle, RaffleStatus status) private view {\\n        if (raffle.status != status) {\\n            revert InvalidStatus();\\n        }\\n    }\\n\\n    /**\\n     * @param caller The expected caller.\\n     */\\n    function _validateCaller(address caller) private view {\\n        if (msg.sender != caller) {\\n            revert InvalidCaller();\\n        }\\n    }\\n\\n    /**\\n     * @param _feeRecipient The new fee recipient address\\n     */\\n    function _setFeeRecipient(address _feeRecipient) private {\\n        if (_feeRecipient == address(0)) {\\n            revert InvalidFeeRecipient();\\n        }\\n        feeRecipient = _feeRecipient;\\n\\n        emit FeeRecipientUpdated(_feeRecipient);\\n    }\\n\\n    function _setFeePrice(uint40 _feePrice) private {\\n        require(_feePrice > 0, \\\"Invalid fee price\\\");\\n\\n        feePrice = _feePrice;\\n\\n        emit FeePriceUpdated(_feePrice);\\n    }\\n\\n    /**\\n     * @param raffle The raffle to set the status of.\\n     * @param raffleId The ID of the raffle to set the status of.\\n     * @param status The status to set.\\n     */\\n    function _setRaffleStatus(Raffle storage raffle, uint256 raffleId, RaffleStatus status) private {\\n        raffle.status = status;\\n        \\n        emit RaffleStatusUpdated(raffleId, status);\\n    }\\n\\n}\\n\",\"keccak256\":\"0x3ac44b9f6f9fca16fe67c44bb5bd47b3f5f5412ee4b3b95eb6caaff746a2b86c\",\"license\":\"MIT\"},\"contracts/interfaces/IRaffleVRF.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\ninterface IRaffleVRF {\\n    enum RaffleStatus {\\n        None,\\n        Open,\\n        Drawing,\\n        RandomnessFulfilled,\\n        Drawn,\\n        Complete\\n    }\\n\\n    enum TokenType {\\n        ERC721,\\n        ERC20\\n    }\\n\\n    /**\\n     * @param entriesCount The number of entries that can be purchased for the given price.\\n     * @param price The price of the entries.\\n     */\\n    struct PricingOption {\\n        uint40 entriesCount;\\n        uint208 price;\\n    }\\n\\n    /**\\n     * @param currentEntryIndex The cumulative number of entries in the raffle.\\n     * @param participant The address of the participant.\\n     */\\n    struct Entry {\\n        uint40 currentEntryIndex;\\n        address participant;\\n    }\\n\\n    /**\\n     * @param participant The address of the winner.\\n     * @param claimed Whether the winner has claimed the prize.\\n     * @param prizeIndex The index of the prize that was won.\\n     * @param entryIndex The index of the entry that won.\\n     */\\n    struct Winner {\\n        address participant;\\n        bool claimed;\\n        uint8 prizeIndex;\\n        uint40 entryIndex;\\n    }\\n\\n    /**\\n     * @param winnersCount The number of winners.\\n     * @param cumulativeWinnersCount The cumulative number of winners in the raffle.\\n     * @param prizeType The type of the prize.\\n     * @param prizeTier The tier of the prize.\\n     * @param prizeAddress The address of the prize.\\n     * @param prizeId The id of the prize.\\n     * @param prizeAmount The amount of the prize.\\n     */\\n    struct Prize {\\n        uint40 winnersCount;\\n        uint40 cumulativeWinnersCount;\\n        TokenType prizeType;\\n        uint8 prizeTier;\\n        address prizeAddress;\\n        uint256 prizeId;\\n        uint256 prizeAmount;\\n    }\\n\\n    /**\\n     * @param owner The address of the raffle owner.\\n     * @param status The status of the raffle.\\n     * @param isMinimumEntriesFixed Whether the minimum number of entries is fixed.\\n     * @param drawnAt The time at which the raffle was drawn.\\n     * @param minimumEntries The minimum number of entries required to draw the raffle.\\n     * @param maximumEntriesPerParticipant The maximum number of entries allowed per participant.\\n     * @param claimableFees The amount of fees collected from selling entries.\\n     * @param pricingOptions The pricing options for the raffle.\\n     * @param prizes The prizes to be distributed.\\n     * @param entries The entries that have been sold.\\n     * @param winners The winners of the raffle.\\n     */\\n    struct Raffle {\\n        address owner;\\n        RaffleStatus status;\\n        bool isMinimumEntriesFixed;\\n        uint40 drawnAt;\\n        uint40 minimumEntries;\\n        uint40 maximumEntriesPerParticipant;\\n        uint208 claimableFees;\\n        PricingOption[5] pricingOptions;\\n        Prize[] prizes;\\n        Entry[] entries;\\n        Winner[] winners;\\n    }\\n\\n    /**\\n     * @param amountPaid The amount paid by the participant.\\n     * @param entriesCount The number of entries purchased by the participant.\\n     * @param refunded Whether the participant has been refunded.\\n     */\\n    struct ParticipantStats {\\n        uint208 amountPaid;\\n        uint40 entriesCount;\\n        bool refunded;\\n    }\\n\\n    /**\\n     * @param raffleId The id of the raffle.\\n     * @param pricingOptionIndex The index of the selected pricing option.\\n     */\\n    struct EntryCalldata {\\n        uint256 raffleId;\\n        uint256 pricingOptionIndex;\\n    }\\n\\n    /**\\n     * @param minimumEntries The minimum number of entries required to draw the raffle.\\n     * @param isMinimumEntriesFixed Whether the minimum number of entries is fixed.\\n     * @param maximumEntriesPerParticipant The maximum number of entries allowed per participant.\\n     * @param prizes The prizes to be distributed.\\n     * @param pricingOptions The pricing options for the raffle.\\n     */\\n    struct CreateRaffleCalldata {\\n        bool isMinimumEntriesFixed;\\n        uint40 minimumEntries;\\n        uint40 maximumEntriesPerParticipant;\\n        Prize[] prizes;\\n        PricingOption[5] pricingOptions;\\n    }\\n\\n    struct ClaimPrizesCalldata {\\n        uint256 raffleId;\\n        uint256[] winnerIndices;\\n    }\\n\\n    /**\\n     * @param exists Whether the request exists.\\n     * @param raffleId The id of the raffle.\\n     * @param randomWord The random words returned by Chainlink VRF.\\n     *                   If randomWord == 0, then the request is still pending.\\n     */\\n    struct RandomnessRequest {\\n        bool exists;\\n        uint248 randomWord;\\n        uint256 raffleId;\\n    }\\n\\n    event CurrenciesStatusUpdated(address[] currencies, bool isAllowed);\\n    event EntryRefunded(uint256 raffleId, address buyer, uint208 amount);\\n    event EntrySold(uint256 raffleId, address buyer, uint40 entriesCount, uint208 price);\\n    event FeesClaimed(uint256 raffleId, uint256 amount);\\n    event PrizesClaimed(uint256 raffleId, uint256[] winnerIndex);\\n    event FeeRecipientUpdated(address feeRecipient);\\n    event FeePriceUpdated(uint40 feePrice);\\n    event RaffleStatusUpdated(uint256 raffleId, RaffleStatus status);\\n    event RandomnessRequested(uint256 raffleId, uint256 requeestId);\\n\\n    event IncreaseRaffleId(uint256 raffleId);\\n\\n\\n    error AlreadyRefunded();\\n    error DrawExpirationTimeNotReached();\\n    error InsufficientNativeTokensSupplied();\\n    error InvalidCaller();\\n    error InvalidCurrency();\\n    error InvalidIndex();\\n    error InvalidPricingOption();\\n    error InvalidPrize();\\n    error InvalidPrizesCount();\\n    error InvalidFeeRecipient();\\n    error InvalidStatus();\\n    error InvalidWinnersCount();\\n    error ERC721TransferFromFail();\\n    error ERC20TransferFromFail();\\n    error ERC20TransferFail();\\n    error MaximumEntriesPerParticipantReached();\\n    error MaximumEntriesReached();\\n    error NotAContract();\\n    error PrizeAlreadyClaimed();\\n    error RandomnessRequestDoesNotExist();\\n    error RandomnessRequestAlreadyExists();\\n\\n    /**\\n     * @notice Creates a new raffle.\\n     * @param params The parameters of the raffle.\\n     * @return raffleId The id of the newly created raffle.\\n     */\\n    function createRaffle(CreateRaffleCalldata calldata params) external returns (uint256 raffleId);\\n\\n    /**\\n     * @notice Deposits prizes for a raffle.\\n     * @param raffleId The id of the raffle.\\n     */\\n    // function depositPrizes(uint256 raffleId) external payable;\\n\\n    /**\\n     * @notice Enters a raffle or multiple raffles.\\n     * @param entries The entries to be made.\\n     */\\n    function enterRaffles(EntryCalldata[] calldata entries) external payable;\\n\\n    /**\\n     * @notice Select the winners for a raffle based on the random words returned by Chainlink.\\n     * @param requestId The request id returned by Chainlink.\\n     */\\n    function selectWinners(uint256 requestId) external;\\n\\n    /**\\n     * @notice Claims the prizes for a winner. A winner can claim multiple prizes\\n     *         from multiple raffles in a single transaction.\\n     * @param claimPrizesCalldata The calldata for claiming prizes.\\n     */\\n    // function claimPrizes(ClaimPrizesCalldata[] calldata claimPrizesCalldata) external;\\n\\n    /**\\n     * @notice Claims the fees collected for a raffle.\\n     * @param raffleId The id of the raffle.\\n     */\\n    function claimFees(uint256 raffleId) external;\\n\\n    /**\\n     * @notice Sets the protocol fee recipient. Only callable by contract owner.\\n     * @param protocolFeeRecipient The protocol fee recipient.\\n     */\\n    function setFeeRecipient(address protocolFeeRecipient) external;\\n    \\n    /**\\n     * @notice Sets the fee price. Only callable by contract owner.\\n     * @param feePrice The fee price.\\n     */\\n    function setFeePrice(uint40 feePrice) external;\\n\\n    /**\\n     * @notice This function allows the owner to update currency statuses.\\n     * @param currencies Currency addresses (address(0) for ETH)\\n     * @param isAllowed Whether the currencies should be allowed for trading\\n     * @dev Only callable by owner.\\n     */\\n    function updateCurrenciesStatus(address[] calldata currencies, bool isAllowed) external;\\n\\n    /**\\n     * @notice Gets the winners for a raffle.\\n     * @param raffleId The id of the raffle.\\n     * @return winners The winners of the raffle.\\n     */\\n    function getWinners(uint256 raffleId) external view returns (Winner[] memory);\\n\\n    /**\\n     * @notice Gets the pricing options for a raffle.\\n     * @param raffleId The id of the raffle.\\n     * @return pricingOptions The pricing options for the raffle.\\n     */\\n    function getPricingOptions(uint256 raffleId) external view returns (PricingOption[5] memory);\\n\\n    /**\\n     * @notice Gets the prizes for a raffle.\\n     * @param raffleId The id of the raffle.\\n     * @return prizes The prizes to be distributed.\\n     */\\n    function getPrizes(uint256 raffleId) external view returns (Prize[] memory);\\n\\n    /**\\n     * @notice Gets the entries for a raffle.\\n     * @param raffleId The id of the raffle.\\n     * @return entries The entries entered for the raffle.\\n     */\\n    function getEntries(uint256 raffleId) external view returns (Entry[] memory);\\n\\n    /**\\n     * @notice Get count of winners.\\n     * @param raffleId The id of the raffle.\\n     * @return winnersCount The count of winners.\\n     */\\n    function getWinnersCount(uint256 raffleId) external view returns (uint256 winnersCount);\\n}\\n\",\"keccak256\":\"0xca592d97c2e3bc36a80733f67a75aa5021d2237a8928681ebbe4ac737a44607d\",\"license\":\"MIT\"},\"contracts/interfaces/generic/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x00de5900712b4cf6d4eb739d325f83aec5a357b25571aaae440aad43eb1e4f05\",\"license\":\"MIT\"},\"contracts/libraries/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport {Math} from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n *      Modified from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Arrays.sol\\n */\\nlibrary Arrays {\\n    /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] memory array, uint256 element) internal pure returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (array[mid] > element) {\\n                high = mid;\\n            } else {\\n                unchecked {\\n                    low = mid + 1;\\n                }\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && array[low - 1] == element) {\\n            unchecked {\\n                return low - 1;\\n            }\\n        } else {\\n            return low;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa14fe4dbe819f18a45cf2fe450e751de97d14ab10f166fecd49832ea6dc21999\",\"license\":\"MIT\"},\"contracts/libraries/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"contracts/libraries/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x7c03cdb0bdf0104db4f87451fc7dd8fb4f94f06dbf176dfc06fd616c1b5937e8\",\"license\":\"MIT\"},\"contracts/libraries/ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0xa535a5df777d44e945dd24aa43a11e44b024140fc340ad0dfe42acf4002aade1\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101006040526007805464ffffffffff60a01b1916610c3560a41b1790553480156200002a57600080fd5b5060405162003583380380620035838339810160408190526200004d9162000217565b6001600160a01b03831660805262000065336200012e565b600180556001600160a01b038216620000c45760405162461bcd60e51b815260206004820152601b60248201527f5a65726f205553445420496e7465726661636520416464726573730000000000604482015260640160405180910390fd5b6001600160a01b038116620000e457620000de336200017e565b620000ef565b620000ef816200017e565b5060a0939093526001600160a01b0390811660e0526001600160401b039190911660c052600280546001600160a01b031916919092161790556200028c565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b038116620001a657604051630ed1b8b360e31b815260040160405180910390fd5b600780546001600160a01b0319166001600160a01b0383169081179091556040519081527f7a7b5a0a132f9e0581eb8527f66eae9ee89c2a3e79d4ac7e41a1f1f4d48a7fc29060200160405180910390a150565b80516001600160a01b03811681146200021257600080fd5b919050565b600080600080600060a086880312156200023057600080fd5b855160208701519095506001600160401b03811681146200025057600080fd5b93506200026060408701620001fa565b92506200027060608701620001fa565b91506200028060808701620001fa565b90509295509295909350565b60805160a05160c05160e0516132a1620002e26000396000818161025701526127f601526000818161020501526127b50152600081816103b801526127860152600081816108a901526108eb01526132a16000f3fe6080604052600436106101ee5760003560e01c806367f082b01161010d578063ac68a748116100a0578063db4f160b1161006f578063db4f160b1461074f578063e74b981b1461076f578063f2fde38b1461078f578063f42df132146107af578063f597573f146107c257600080fd5b8063ac68a748146106c0578063b190d8a3146106e0578063cc307795146106f5578063d3549ebd1461072257600080fd5b80636b1426a4116100dc5780636b1426a4146105d7578063715018a6146106045780638da5cb5b14610619578063a17be1541461063757600080fd5b806367f082b01461055a578063689869121461058257806369894cf714610597578063699e9771146105b757600080fd5b806346904840116101855780635a195d19116101545780635a195d19146103ff5780635cb6dfff1461043f5780635d4bc0ce146104ac57806365d697f71461054557600080fd5b806346904840146103625780634d2c53cd1461038257806351dc86a5146103a657806354ad9718146103da57600080fd5b806326d1115a116101c157806326d1115a146102d357806331fe74a9146102ff57806339a2eb2a1461032c5780633b6cb1531461034c57600080fd5b8063030932bb146101f357806305f6a924146102455780631e9f1a82146102915780631fe543e3146102b3575b600080fd5b3480156101ff57600080fd5b506102277f000000000000000000000000000000000000000000000000000000000000000081565b60405167ffffffffffffffff90911681526020015b60405180910390f35b34801561025157600080fd5b506102797f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161023c565b34801561029d57600080fd5b506102b16102ac366004612987565b6107e2565b005b3480156102bf57600080fd5b506102b16102ce366004612a54565b61089e565b3480156102df57600080fd5b506102e96103e881565b60405164ffffffffff909116815260200161023c565b34801561030b57600080fd5b5061031f61031a366004612b06565b61092b565b60405161023c9190612b1f565b34801561033857600080fd5b506102b1610347366004612b06565b6109ab565b34801561035857600080fd5b506102e96109c481565b34801561036e57600080fd5b50600754610279906001600160a01b031681565b34801561038e57600080fd5b5061039860035481565b60405190815260200161023c565b3480156103b257600080fd5b506103987f000000000000000000000000000000000000000000000000000000000000000081565b3480156103e657600080fd5b506007546102e990600160a01b900464ffffffffff1681565b34801561040b57600080fd5b5061042f61041a366004612b89565b60066020526000908152604090205460ff1681565b604051901515815260200161023c565b34801561044b57600080fd5b5061048761045a366004612b06565b6008602052600090815260409020805460019091015460ff82169161010090046001600160f81b03169083565b6040805193151584526001600160f81b0390921660208401529082015260600161023c565b3480156104b857600080fd5b506105326104c7366004612b06565b600460205260009081526040902080546001909101546001600160a01b0382169160ff600160a01b8204811692600160a81b83049091169164ffffffffff600160b01b8204811692600160d81b909204811691908116906001600160d01b03600160281b9091041687565b60405161023c9796959493929190612bce565b34801561055157600080fd5b50610398601481565b34801561056657600080fd5b5061056f600381565b60405161ffff909116815260200161023c565b34801561058e57600080fd5b50610398600581565b3480156105a357600080fd5b506103986105b2366004612b06565b610e2d565b3480156105c357600080fd5b506102b16105d2366004612c3c565b6111f6565b3480156105e357600080fd5b506105f76105f2366004612b06565b61120a565b60405161023c9190612c57565b34801561061057600080fd5b506102b16112b1565b34801561062557600080fd5b506000546001600160a01b0316610279565b34801561064357600080fd5b50610693610652366004612cd0565b60056020908152600092835260408084209091529082529020546001600160d01b03811690600160d01b810464ffffffffff1690600160f81b900460ff1683565b604080516001600160d01b03909416845264ffffffffff909216602084015215159082015260600161023c565b3480156106cc57600080fd5b506102b16106db366004612b06565b6112c5565b3480156106ec57600080fd5b50600954610398565b34801561070157600080fd5b50610715610710366004612b06565b611648565b60405161023c9190612cfc565b34801561072e57600080fd5b5061074261073d366004612b06565b611747565b60405161023c9190612d97565b34801561075b57600080fd5b5061039861076a366004612de9565b6117cc565b34801561077b57600080fd5b506102b161078a366004612b89565b611ac0565b34801561079b57600080fd5b506102b16107aa366004612b89565b611ad1565b6102b16107bd366004612e25565b611b47565b3480156107ce57600080fd5b50600254610279906001600160a01b031681565b6107ea6120b1565b8160005b8181101561085c57826006600087878581811061080d5761080d612e9a565b90506020020160208101906108229190612b89565b6001600160a01b031681526020810191909152604001600020805460ff19169115159190911790558061085481612ec6565b9150506107ee565b507fcb2fef16ee9f3ea43e174daf88ffcdc8beee4ad884c7570093d998d71058698784848460405161089093929190612edf565b60405180910390a150505050565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461091d5760405163073e64fd60e21b81523360048201526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001660248201526044015b60405180910390fd5b610927828261210b565b5050565b610933612940565b600082815260046020526040808220815160a081019092529091600290910190600590835b828210156109a057604080518082019091528483015464ffffffffff81168252600160281b90046001600160d01b031660208083019190915290825260019092019101610958565b505050509050919050565b6000818152600860209081526040918290208251606081018452815460ff811615158083526101009091046001600160f81b03169382019390935260019091015492810192909252610a10576040516306dc6a1360e21b815260040160405180910390fd5b6040808201516000818152600460205291909120610a2f8160036121db565b80546001600160a01b0316338114610a5b57610a5b610a566000546001600160a01b031690565b612228565b600782018054600082610a6f600184612f36565b81548110610a7f57610a7f612e9a565b906000526020600020906003020160000160059054906101000a900464ffffffffff1664ffffffffff169050600085600801805480602002602001604051908101604052809291908181526020016000905b82821015610b1e576000848152602090819020604080518082019091529084015464ffffffffff81168252600160281b90046001600160a01b031681830152825260019092019101610ad1565b5050825192935060009150839050610b37600184612f36565b81518110610b4757610b47612e9a565b60200260200101516000015164ffffffffff16905060008267ffffffffffffffff811115610b7757610b77612a0d565b604051908082528060200260200182016040528015610ba0578160200160208202803683370190505b50905060005b83811015610c0257848181518110610bc057610bc0612e9a565b60200260200101516000015164ffffffffff16828281518110610be557610be5612e9a565b602090810291909101015280610bfa81612ec6565b915050610ba6565b5060008667ffffffffffffffff811115610c1e57610c1e612a0d565b604051908082528060200260200182016040528015610c47578160200160208202803683370190505b50905060005b87811015610cc057888181548110610c6757610c67612e9a565b906000526020600020906003020160000160059054906101000a900464ffffffffff1664ffffffffff16828281518110610ca357610ca3612e9a565b602090810291909101015280610cb881612ec6565b915050610c4d565b5060208c01516001600160f81b031660005b87811015610e10576000610ce7866001612f49565b610cf19084612f72565b90508c60090160405180608001604052808a610d16858a61225190919063ffffffff16565b81518110610d2657610d26612e9a565b6020026020010151602001516001600160a01b03168152602001600015158152602001610d60856001610d599190612f49565b8890612251565b60ff908116825264ffffffffff9485166020928301528354600181018555600094855293829020835194018054928401516040850151606090950151909616600160b01b0264ffffffffff60b01b1994909216600160a81b029390931665ffffffffffff60a81b19951515600160a01b026001600160a81b03199093166001600160a01b039095169490941791909117939093169190911791909117905580610e0881612ec6565b915050610cd2565b50610e1d8b8d6004612303565b5050505050505050505050505050565b60008082118015610e4057506003548211155b610e805760405162461bcd60e51b8152602060048201526011602482015270125b9d985b1a59081c9859999b19481251607a1b6044820152606401610914565b60008281526004602090815260408083208151610160810190925280546001600160a01b03811683529192909190830190600160a01b900460ff166005811115610ecc57610ecc612ba4565b6005811115610edd57610edd612ba4565b8152815460ff600160a81b8204161515602083015264ffffffffff600160b01b82048116604080850191909152600160d81b90920481166060840152600184015490811660808401526001600160d01b03600160281b9091041660a080840191909152815190810190915260c0909101906002830160056000835b82821015610fa057604080518082019091528483015464ffffffffff81168252600160281b90046001600160d01b031660208083019190915290825260019092019101610f58565b50505050815260200160078201805480602002602001604051908101604052809291908181526020016000905b828210156110945760008481526020908190206040805160e08101825260038602909201805464ffffffffff8082168552600160281b82041694840194909452919290830190600160501b900460ff16600181111561102e5761102e612ba4565b600181111561103f5761103f612ba4565b81528154600160581b810460ff16602080840191909152600160601b9091046001600160a01b031660408301526001808401546060840152600290930154608090920191909152918352929092019101610fcd565b50505050815260200160088201805480602002602001604051908101604052809291908181526020016000905b8282101561110e576000848152602090819020604080518082019091529084015464ffffffffff81168252600160281b90046001600160a01b0316818301528252600190920191016110c1565b50505050815260200160098201805480602002602001604051908101604052809291908181526020016000905b828210156111aa57600084815260209081902060408051608081018252918501546001600160a01b038116835260ff600160a01b82048116151584860152600160a81b8204169183019190915264ffffffffff600160b01b90910416606082015282526001909201910161113b565b50505091525050610100810151805191925090816111c9600183612f36565b815181106111d9576111d9612e9a565b60200260200101516020015164ffffffffff169350505050919050565b6111fe6120b1565b6112078161236a565b50565b606060046000838152602001908152602001600020600901805480602002602001604051908101604052809291908181526020016000905b828210156109a057600084815260209081902060408051608081018252918501546001600160a01b038116835260ff600160a01b82048116151584860152600160a81b8204169183019190915264ffffffffff600160b01b909104166060820152825260019092019101611242565b6112b96120b1565b6112c36000612412565b565b6112cd612462565b6000818152600460208190526040909120906112ea9082906121db565b80546001600160a01b031633811461131157611311610a566000546001600160a01b031690565b600082600801805480602002602001604051908101604052809291908181526020016000905b82821015611384576000848152602090819020604080518082019091529084015464ffffffffff81168252600160281b90046001600160a01b031681830152825260019092019101611337565b505082519293506000915083905061139d600184612f36565b815181106113ad576113ad612e9a565b60200260200101516000015164ffffffffff16905060008560010160059054906101000a90046001600160d01b03166001600160d01b0316905060008260016113f69190612f49565b6007546114119190600160a01b900464ffffffffff16612f86565b60025460405163095ea7b360e01b8152306004820152602481018590529192506001600160a01b03169063095ea7b3906044016020604051808303816000875af1158015611463573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114879190612f9d565b6114c95760405162461bcd60e51b81526020600482015260136024820152721554d11508185c1c1c9bdd994819985a5b1959606a1b6044820152606401610914565b6114d38183612f36565b6002546007546040516323b872dd60e01b81523060048201526001600160a01b0391821660248201526044810185905292945016906323b872dd906064016020604051808303816000875af1158015611530573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115549190612f9d565b506002546040516323b872dd60e01b8152306004820152336024820152604481018490526001600160a01b03909116906323b872dd906064016020604051808303816000875af11580156115ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115d09190612f9d565b5060018701805465010000000000600160f81b03191690556115f487896005612303565b7fa1f87f32d0f17fab0242ca800d736293de8988c14b27747e218cf13d5c249f53886116208484612f49565b6040805192835260208301919091520160405180910390a15050505050505061120760018055565b606060046000838152602001908152602001600020600701805480602002602001604051908101604052809291908181526020016000905b828210156109a05760008481526020908190206040805160e08101825260038602909201805464ffffffffff8082168552600160281b82041694840194909452919290830190600160501b900460ff1660018111156116e1576116e1612ba4565b60018111156116f2576116f2612ba4565b81528154600160581b810460ff16602080840191909152600160601b9091046001600160a01b031660408301526001808401546060840152600290930154608090920191909152918352929092019101611680565b606060046000838152602001908152602001600020600801805480602002602001604051908101604052809291908181526020016000905b828210156109a0576000848152602090819020604080518082019091529084015464ffffffffff81168252600160281b90046001600160a01b03168183015282526001909201910161177f565b60006117d66120b1565b6003600081546117e590612ec6565b9182905550905060006117fb6060840184612fba565b91505080158061180b5750601481115b156118295760405163ab13062d60e01b815260040160405180910390fd5b60008281526004602052604081209080805b848110156119be5760006118526060890189612fba565b8381811061186257611862612e9a565b905060e00201803603810190611878919061301b565b90508260ff16816060015160ff1610156118a557604051632f89717760e11b815260040160405180910390fd5b6118ae816124bb565b80516118ba90856130c6565b64ffffffffff8082166020808501918252606085015160078a018054600181810183556000928352939091208751600390920201805494518616600160281b0269ffffffffffffffffffff199095169190951617929092178084556040860151949850919650849391839160ff60501b1990911690600160501b90849081111561194657611946612ba4565b02179055506060820151815460808401516001600160a01b0316600160601b026bffffffffffffffffffffffff60ff909316600160581b02929092166affffffffffffffffffffff9091161717815560a0820151600182015560c09091015160029091015550806119b681612ec6565b91505061183b565b5060006119d16040880160208901612c3c565b90508064ffffffffff168364ffffffffff1611806119f757506109c464ffffffffff8416115b15611a15576040516340250f0160e11b815260040160405180910390fd5b611a2286886080016125a2565b83546001600160a01b03191633178455611a3f60208801886130eb565b8454600165ffffffffff0160a81b0316600160a81b911515919091026001600160d81b031617600160d81b64ffffffffff831602178455611a866060880160408901612c3c565b8460010160006101000a81548164ffffffffff021916908364ffffffffff160217905550611ab684876001612303565b5050505050919050565b611ac86120b1565b61120781612693565b611ad96120b1565b6001600160a01b038116611b3e5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610914565b61120781612412565b611b4f612462565b600254604051636eb1769f60e11b8152336004820152306024820152829160009182916001600160a01b03169063dd62ed3e90604401602060405180830381865afa158015611ba2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bc69190613108565b905060005b838110156120205736868683818110611be657611be6612e9a565b90506040020190506005816020013510611c13576040516363df817160e01b815260040160405180910390fd5b80356000818152600460205260409020611c2e8160016121db565b600081600201846020013560058110611c4957611c49612e9a565b604080518082018252919092015464ffffffffff808216808452600160281b9092046001600160d01b031660208085019190915260008881526005825285812033825290915293842054929450611ca792600160d01b9004166130c6565b600184015490915064ffffffffff9081169082161115611cda5760405163d085f16160e01b815260040160405180910390fd5b60008481526005602090815260408083203384528252909120805464ffffffffff60d01b1916600160d01b64ffffffffff851602179055820151611d1e818a613121565b9850611d5c6040518060400160405280601181526020017065787065637465645553445456616c756560781b8152508a6001600160d01b0316612708565b611d8d6040518060400160405280600f81526020016e757365725553445442616c616e636560881b81525089612708565b87896001600160d01b03161115611de0576040805180820182526014815273496e73756666696369656e742062616c616e636560601b6020820152905162461bcd60e51b81526109149190600401613187565b6008840154600090808203611e04578451611dfd9060019061319a565b9150611e45565b845160088701611e15600184612f36565b81548110611e2557611e25612e9a565b600091825260209091200154611e42919064ffffffffff166130c6565b91505b8554600160a81b900460ff1615611e8957855464ffffffffff600160d81b909104811690831610611e89576040516334b3fb3b60e01b815260040160405180910390fd5b6040805180820190915264ffffffffff838116825233602080840191825260088a018054600180820183556000928352929091209451940180549251949093166001600160c81b031990921691909117600160281b6001600160a01b03909416840217909155870180548592600591611f0d918591046001600160d01b0316613121565b82546101009290920a6001600160d01b038181021990931691831602179091556000898152600560209081526040808320338452909152812080548794509092611f5991859116613121565b82546101009290920a6001600160d01b038181021990931691831602179091558651604080518b815233602082015264ffffffffff9092169082015290851660608201527fc25cd4cec0cbfb9bc40ad8f59ac733efcddf6ed3b7519369c9b9ceb2ee784601915060800160405180910390a18554611fe790600190600160d81b900464ffffffffff1661319a565b64ffffffffff168264ffffffffff161061200557612005878761274d565b5050505050505050808061201890612ec6565b915050611bcb565b506002546040516323b872dd60e01b81523360048201523060248201526001600160d01b03841660448201526001600160a01b03909116906323b872dd906064016020604051808303816000875af1158015612080573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120a49190612f9d565b5050505061092760018055565b6000546001600160a01b031633146112c35760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610914565b60008281526008602052604090205460ff16801561212a575081600954145b1561092757600082815260086020908152604080832060010154808452600490925290912060028154600160a01b900460ff16600581111561216e5761216e612ba4565b036121d55761217f81836003612303565b8260008151811061219257612192612e9a565b60200260200101516008600086815260200190815260200160002060000160016101000a8154816001600160f81b0302191690836001600160f81b031602179055505b50505050565b8060058111156121ed576121ed612ba4565b8254600160a01b900460ff16600581111561220a5761220a612ba4565b14610927576040516307a92f1960e51b815260040160405180910390fd5b336001600160a01b03821614611207576040516348f5c3ed60e01b815260040160405180910390fd5b60008251600003612264575060006122fd565b82516000905b808210156122b657600061227e83836128f9565b90508486828151811061229357612293612e9a565b602002602001015111156122a9578091506122b0565b8060010192505b5061226a565b6000821180156122e8575083856122ce600185612f36565b815181106122de576122de612e9a565b6020026020010151145b156122f957506000190190506122fd565b5090505b92915050565b82548190849060ff60a01b1916600160a01b83600581111561232757612327612ba4565b02179055507fc1191e7178b58ad510709587719f39ec315fa79e81ee7ba5c5ef3c894e94a651828260405161235d9291906131b8565b60405180910390a1505050565b60008164ffffffffff16116123b55760405162461bcd60e51b8152602060048201526011602482015270496e76616c69642066656520707269636560781b6044820152606401610914565b6007805464ffffffffff60a01b1916600160a01b64ffffffffff8416908102919091179091556040519081527f27b7f58ff9b5d7747c74d7d1bc186900d393741413f16db047f574afa1249820906020015b60405180910390a150565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6002600154036124b45760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610914565b6002600155565b6000816040015160018111156124d3576124d3612ba4565b03612516578060c0015160011415806124f85750806000015164ffffffffff16600114155b1561120757604051632f89717760e11b815260040160405180910390fd5b60018160400151600181111561252e5761252e612ba4565b036125705760808101516001600160a01b031660009081526006602052604090205460ff1661257057604051631eb3268560e31b815260040160405180910390fd5b60c081015115806124f85750805164ffffffffff1661120757604051632f89717760e11b815260040160405180910390fd5b60005b600581101561268e5760008282600581106125c2576125c2612e9a565b604002018036038101906125d691906131cc565b805160208201519192509064ffffffffff821615806125fc57506001600160d01b038116155b1561261957604051625cba9760e51b815260040160405180910390fd5b60008681526004602052604090208390600201856005811061263d5761263d612e9a565b8251910180546020909301516001600160d01b0316600160281b026001600160f81b031990931664ffffffffff9092169190911791909117905550829150612686905081612ec6565b9150506125a5565b505050565b6001600160a01b0381166126ba57604051630ed1b8b360e31b815260040160405180910390fd5b600780546001600160a01b0319166001600160a01b0383169081179091556040519081527f7a7b5a0a132f9e0581eb8527f66eae9ee89c2a3e79d4ac7e41a1f1f4d48a7fc290602001612407565b610927828260405160240161271e929190613235565b60408051601f198184030181529190526020810180516001600160e01b0316632d839cb360e21b17905261291b565b61275981836002612303565b805464ffffffffff60b01b1916600160b01b4264ffffffffff16021781556040516305d3b1d360e41b81527f0000000000000000000000000000000000000000000000000000000000000000600482015267ffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000166024820152600360448201526207a1206064820152600160848201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690635d3b1d309060a4016020604051808303816000875af1158015612847573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061286b9190613108565b600981905560008181526008602052604090205490915060ff16156128a357604051637c80909960e11b815260040160405180910390fd5b600081815260086020908152604091829020805460ff1916600190811782550185905581518581529081018390527f3d94fecedaa4f90b8bd459797adb95f5bb11426025c5541390d9ccc1ad1b60a1910161235d565b60006129086002848418613257565b61291490848416612f49565b9392505050565b6112078160006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b6040518060a001604052806005905b604080518082019091526000808252602082015281526020019060019003908161294f5790505090565b801515811461120757600080fd5b60008060006040848603121561299c57600080fd5b833567ffffffffffffffff808211156129b457600080fd5b818601915086601f8301126129c857600080fd5b8135818111156129d757600080fd5b8760208260051b85010111156129ec57600080fd5b60209283019550935050840135612a0281612979565b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715612a4c57612a4c612a0d565b604052919050565b60008060408385031215612a6757600080fd5b8235915060208084013567ffffffffffffffff80821115612a8757600080fd5b818601915086601f830112612a9b57600080fd5b813581811115612aad57612aad612a0d565b8060051b9150612abe848301612a23565b8181529183018401918481019089841115612ad857600080fd5b938501935b83851015612af657843582529385019390850190612add565b8096505050505050509250929050565b600060208284031215612b1857600080fd5b5035919050565b6101408101818360005b6005811015612b64578151805164ffffffffff1684526020908101516001600160d01b03168185015260409093019290910190600101612b29565b50505092915050565b80356001600160a01b0381168114612b8457600080fd5b919050565b600060208284031215612b9b57600080fd5b61291482612b6d565b634e487b7160e01b600052602160045260246000fd5b60068110612bca57612bca612ba4565b9052565b6001600160a01b038816815260e08101612beb6020830189612bba565b951515604082015264ffffffffff94851660608201529284166080840152921660a08201526001600160d01b0390911660c09091015292915050565b803564ffffffffff81168114612b8457600080fd5b600060208284031215612c4e57600080fd5b61291482612c27565b602080825282518282018190526000919060409081850190868401855b82811015612cc357815180516001600160a01b03168552868101511515878601528581015160ff168686015260609081015164ffffffffff169085015260809093019290850190600101612c74565b5091979650505050505050565b60008060408385031215612ce357600080fd5b82359150612cf360208401612b6d565b90509250929050565b602080825282518282018190526000919060409081850190868401855b82811015612cc3578151805164ffffffffff90811686528782015116878601528581015160028110612d4d57612d4d612ba4565b8587015260608181015160ff16908601526080808201516001600160a01b03169086015260a0808201519086015260c0908101519085015260e09093019290850190600101612d19565b602080825282518282018190526000919060409081850190868401855b82811015612cc3578151805164ffffffffff1685528601516001600160a01b0316868501529284019290850190600101612db4565b600060208284031215612dfb57600080fd5b813567ffffffffffffffff811115612e1257600080fd5b82016101c0818503121561291457600080fd5b60008060208385031215612e3857600080fd5b823567ffffffffffffffff80821115612e5057600080fd5b818501915085601f830112612e6457600080fd5b813581811115612e7357600080fd5b8660208260061b8501011115612e8857600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600060018201612ed857612ed8612eb0565b5060010190565b6040808252810183905260008460608301825b86811015612f20576001600160a01b03612f0b84612b6d565b16825260209283019290910190600101612ef2565b5080925050508215156020830152949350505050565b818103818111156122fd576122fd612eb0565b808201808211156122fd576122fd612eb0565b634e487b7160e01b600052601260045260246000fd5b600082612f8157612f81612f5c565b500690565b80820281158282048414176122fd576122fd612eb0565b600060208284031215612faf57600080fd5b815161291481612979565b6000808335601e19843603018112612fd157600080fd5b83018035915067ffffffffffffffff821115612fec57600080fd5b602001915060e08102360382131561300357600080fd5b9250929050565b803560ff81168114612b8457600080fd5b600060e0828403121561302d57600080fd5b60405160e0810181811067ffffffffffffffff8211171561305057613050612a0d565b60405261305c83612c27565b815261306a60208401612c27565b602082015260408301356002811061308157600080fd5b60408201526130926060840161300a565b60608201526130a360808401612b6d565b608082015260a083013560a082015260c083013560c08201528091505092915050565b64ffffffffff8181168382160190808211156130e4576130e4612eb0565b5092915050565b6000602082840312156130fd57600080fd5b813561291481612979565b60006020828403121561311a57600080fd5b5051919050565b6001600160d01b038181168382160190808211156130e4576130e4612eb0565b6000815180845260005b818110156131675760208185018101518683018201520161314b565b506000602082860101526020601f19601f83011685010191505092915050565b6020815260006129146020830184613141565b64ffffffffff8281168282160390808211156130e4576130e4612eb0565b828152604081016129146020830184612bba565b6000604082840312156131de57600080fd5b6040516040810181811067ffffffffffffffff8211171561320157613201612a0d565b60405261320d83612c27565b815260208301356001600160d01b038116811461322957600080fd5b60208201529392505050565b6040815260006132486040830185613141565b90508260208301529392505050565b60008261326657613266612f5c565b50049056fea2646970667358221220900f7b50d9f92e6297861c0a8a472039416cb571dfc91d1d0c85ada92385530f64736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436106101ee5760003560e01c806367f082b01161010d578063ac68a748116100a0578063db4f160b1161006f578063db4f160b1461074f578063e74b981b1461076f578063f2fde38b1461078f578063f42df132146107af578063f597573f146107c257600080fd5b8063ac68a748146106c0578063b190d8a3146106e0578063cc307795146106f5578063d3549ebd1461072257600080fd5b80636b1426a4116100dc5780636b1426a4146105d7578063715018a6146106045780638da5cb5b14610619578063a17be1541461063757600080fd5b806367f082b01461055a578063689869121461058257806369894cf714610597578063699e9771146105b757600080fd5b806346904840116101855780635a195d19116101545780635a195d19146103ff5780635cb6dfff1461043f5780635d4bc0ce146104ac57806365d697f71461054557600080fd5b806346904840146103625780634d2c53cd1461038257806351dc86a5146103a657806354ad9718146103da57600080fd5b806326d1115a116101c157806326d1115a146102d357806331fe74a9146102ff57806339a2eb2a1461032c5780633b6cb1531461034c57600080fd5b8063030932bb146101f357806305f6a924146102455780631e9f1a82146102915780631fe543e3146102b3575b600080fd5b3480156101ff57600080fd5b506102277f000000000000000000000000000000000000000000000000000000000000000081565b60405167ffffffffffffffff90911681526020015b60405180910390f35b34801561025157600080fd5b506102797f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b03909116815260200161023c565b34801561029d57600080fd5b506102b16102ac366004612987565b6107e2565b005b3480156102bf57600080fd5b506102b16102ce366004612a54565b61089e565b3480156102df57600080fd5b506102e96103e881565b60405164ffffffffff909116815260200161023c565b34801561030b57600080fd5b5061031f61031a366004612b06565b61092b565b60405161023c9190612b1f565b34801561033857600080fd5b506102b1610347366004612b06565b6109ab565b34801561035857600080fd5b506102e96109c481565b34801561036e57600080fd5b50600754610279906001600160a01b031681565b34801561038e57600080fd5b5061039860035481565b60405190815260200161023c565b3480156103b257600080fd5b506103987f000000000000000000000000000000000000000000000000000000000000000081565b3480156103e657600080fd5b506007546102e990600160a01b900464ffffffffff1681565b34801561040b57600080fd5b5061042f61041a366004612b89565b60066020526000908152604090205460ff1681565b604051901515815260200161023c565b34801561044b57600080fd5b5061048761045a366004612b06565b6008602052600090815260409020805460019091015460ff82169161010090046001600160f81b03169083565b6040805193151584526001600160f81b0390921660208401529082015260600161023c565b3480156104b857600080fd5b506105326104c7366004612b06565b600460205260009081526040902080546001909101546001600160a01b0382169160ff600160a01b8204811692600160a81b83049091169164ffffffffff600160b01b8204811692600160d81b909204811691908116906001600160d01b03600160281b9091041687565b60405161023c9796959493929190612bce565b34801561055157600080fd5b50610398601481565b34801561056657600080fd5b5061056f600381565b60405161ffff909116815260200161023c565b34801561058e57600080fd5b50610398600581565b3480156105a357600080fd5b506103986105b2366004612b06565b610e2d565b3480156105c357600080fd5b506102b16105d2366004612c3c565b6111f6565b3480156105e357600080fd5b506105f76105f2366004612b06565b61120a565b60405161023c9190612c57565b34801561061057600080fd5b506102b16112b1565b34801561062557600080fd5b506000546001600160a01b0316610279565b34801561064357600080fd5b50610693610652366004612cd0565b60056020908152600092835260408084209091529082529020546001600160d01b03811690600160d01b810464ffffffffff1690600160f81b900460ff1683565b604080516001600160d01b03909416845264ffffffffff909216602084015215159082015260600161023c565b3480156106cc57600080fd5b506102b16106db366004612b06565b6112c5565b3480156106ec57600080fd5b50600954610398565b34801561070157600080fd5b50610715610710366004612b06565b611648565b60405161023c9190612cfc565b34801561072e57600080fd5b5061074261073d366004612b06565b611747565b60405161023c9190612d97565b34801561075b57600080fd5b5061039861076a366004612de9565b6117cc565b34801561077b57600080fd5b506102b161078a366004612b89565b611ac0565b34801561079b57600080fd5b506102b16107aa366004612b89565b611ad1565b6102b16107bd366004612e25565b611b47565b3480156107ce57600080fd5b50600254610279906001600160a01b031681565b6107ea6120b1565b8160005b8181101561085c57826006600087878581811061080d5761080d612e9a565b90506020020160208101906108229190612b89565b6001600160a01b031681526020810191909152604001600020805460ff19169115159190911790558061085481612ec6565b9150506107ee565b507fcb2fef16ee9f3ea43e174daf88ffcdc8beee4ad884c7570093d998d71058698784848460405161089093929190612edf565b60405180910390a150505050565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461091d5760405163073e64fd60e21b81523360048201526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001660248201526044015b60405180910390fd5b610927828261210b565b5050565b610933612940565b600082815260046020526040808220815160a081019092529091600290910190600590835b828210156109a057604080518082019091528483015464ffffffffff81168252600160281b90046001600160d01b031660208083019190915290825260019092019101610958565b505050509050919050565b6000818152600860209081526040918290208251606081018452815460ff811615158083526101009091046001600160f81b03169382019390935260019091015492810192909252610a10576040516306dc6a1360e21b815260040160405180910390fd5b6040808201516000818152600460205291909120610a2f8160036121db565b80546001600160a01b0316338114610a5b57610a5b610a566000546001600160a01b031690565b612228565b600782018054600082610a6f600184612f36565b81548110610a7f57610a7f612e9a565b906000526020600020906003020160000160059054906101000a900464ffffffffff1664ffffffffff169050600085600801805480602002602001604051908101604052809291908181526020016000905b82821015610b1e576000848152602090819020604080518082019091529084015464ffffffffff81168252600160281b90046001600160a01b031681830152825260019092019101610ad1565b5050825192935060009150839050610b37600184612f36565b81518110610b4757610b47612e9a565b60200260200101516000015164ffffffffff16905060008267ffffffffffffffff811115610b7757610b77612a0d565b604051908082528060200260200182016040528015610ba0578160200160208202803683370190505b50905060005b83811015610c0257848181518110610bc057610bc0612e9a565b60200260200101516000015164ffffffffff16828281518110610be557610be5612e9a565b602090810291909101015280610bfa81612ec6565b915050610ba6565b5060008667ffffffffffffffff811115610c1e57610c1e612a0d565b604051908082528060200260200182016040528015610c47578160200160208202803683370190505b50905060005b87811015610cc057888181548110610c6757610c67612e9a565b906000526020600020906003020160000160059054906101000a900464ffffffffff1664ffffffffff16828281518110610ca357610ca3612e9a565b602090810291909101015280610cb881612ec6565b915050610c4d565b5060208c01516001600160f81b031660005b87811015610e10576000610ce7866001612f49565b610cf19084612f72565b90508c60090160405180608001604052808a610d16858a61225190919063ffffffff16565b81518110610d2657610d26612e9a565b6020026020010151602001516001600160a01b03168152602001600015158152602001610d60856001610d599190612f49565b8890612251565b60ff908116825264ffffffffff9485166020928301528354600181018555600094855293829020835194018054928401516040850151606090950151909616600160b01b0264ffffffffff60b01b1994909216600160a81b029390931665ffffffffffff60a81b19951515600160a01b026001600160a81b03199093166001600160a01b039095169490941791909117939093169190911791909117905580610e0881612ec6565b915050610cd2565b50610e1d8b8d6004612303565b5050505050505050505050505050565b60008082118015610e4057506003548211155b610e805760405162461bcd60e51b8152602060048201526011602482015270125b9d985b1a59081c9859999b19481251607a1b6044820152606401610914565b60008281526004602090815260408083208151610160810190925280546001600160a01b03811683529192909190830190600160a01b900460ff166005811115610ecc57610ecc612ba4565b6005811115610edd57610edd612ba4565b8152815460ff600160a81b8204161515602083015264ffffffffff600160b01b82048116604080850191909152600160d81b90920481166060840152600184015490811660808401526001600160d01b03600160281b9091041660a080840191909152815190810190915260c0909101906002830160056000835b82821015610fa057604080518082019091528483015464ffffffffff81168252600160281b90046001600160d01b031660208083019190915290825260019092019101610f58565b50505050815260200160078201805480602002602001604051908101604052809291908181526020016000905b828210156110945760008481526020908190206040805160e08101825260038602909201805464ffffffffff8082168552600160281b82041694840194909452919290830190600160501b900460ff16600181111561102e5761102e612ba4565b600181111561103f5761103f612ba4565b81528154600160581b810460ff16602080840191909152600160601b9091046001600160a01b031660408301526001808401546060840152600290930154608090920191909152918352929092019101610fcd565b50505050815260200160088201805480602002602001604051908101604052809291908181526020016000905b8282101561110e576000848152602090819020604080518082019091529084015464ffffffffff81168252600160281b90046001600160a01b0316818301528252600190920191016110c1565b50505050815260200160098201805480602002602001604051908101604052809291908181526020016000905b828210156111aa57600084815260209081902060408051608081018252918501546001600160a01b038116835260ff600160a01b82048116151584860152600160a81b8204169183019190915264ffffffffff600160b01b90910416606082015282526001909201910161113b565b50505091525050610100810151805191925090816111c9600183612f36565b815181106111d9576111d9612e9a565b60200260200101516020015164ffffffffff169350505050919050565b6111fe6120b1565b6112078161236a565b50565b606060046000838152602001908152602001600020600901805480602002602001604051908101604052809291908181526020016000905b828210156109a057600084815260209081902060408051608081018252918501546001600160a01b038116835260ff600160a01b82048116151584860152600160a81b8204169183019190915264ffffffffff600160b01b909104166060820152825260019092019101611242565b6112b96120b1565b6112c36000612412565b565b6112cd612462565b6000818152600460208190526040909120906112ea9082906121db565b80546001600160a01b031633811461131157611311610a566000546001600160a01b031690565b600082600801805480602002602001604051908101604052809291908181526020016000905b82821015611384576000848152602090819020604080518082019091529084015464ffffffffff81168252600160281b90046001600160a01b031681830152825260019092019101611337565b505082519293506000915083905061139d600184612f36565b815181106113ad576113ad612e9a565b60200260200101516000015164ffffffffff16905060008560010160059054906101000a90046001600160d01b03166001600160d01b0316905060008260016113f69190612f49565b6007546114119190600160a01b900464ffffffffff16612f86565b60025460405163095ea7b360e01b8152306004820152602481018590529192506001600160a01b03169063095ea7b3906044016020604051808303816000875af1158015611463573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114879190612f9d565b6114c95760405162461bcd60e51b81526020600482015260136024820152721554d11508185c1c1c9bdd994819985a5b1959606a1b6044820152606401610914565b6114d38183612f36565b6002546007546040516323b872dd60e01b81523060048201526001600160a01b0391821660248201526044810185905292945016906323b872dd906064016020604051808303816000875af1158015611530573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115549190612f9d565b506002546040516323b872dd60e01b8152306004820152336024820152604481018490526001600160a01b03909116906323b872dd906064016020604051808303816000875af11580156115ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115d09190612f9d565b5060018701805465010000000000600160f81b03191690556115f487896005612303565b7fa1f87f32d0f17fab0242ca800d736293de8988c14b27747e218cf13d5c249f53886116208484612f49565b6040805192835260208301919091520160405180910390a15050505050505061120760018055565b606060046000838152602001908152602001600020600701805480602002602001604051908101604052809291908181526020016000905b828210156109a05760008481526020908190206040805160e08101825260038602909201805464ffffffffff8082168552600160281b82041694840194909452919290830190600160501b900460ff1660018111156116e1576116e1612ba4565b60018111156116f2576116f2612ba4565b81528154600160581b810460ff16602080840191909152600160601b9091046001600160a01b031660408301526001808401546060840152600290930154608090920191909152918352929092019101611680565b606060046000838152602001908152602001600020600801805480602002602001604051908101604052809291908181526020016000905b828210156109a0576000848152602090819020604080518082019091529084015464ffffffffff81168252600160281b90046001600160a01b03168183015282526001909201910161177f565b60006117d66120b1565b6003600081546117e590612ec6565b9182905550905060006117fb6060840184612fba565b91505080158061180b5750601481115b156118295760405163ab13062d60e01b815260040160405180910390fd5b60008281526004602052604081209080805b848110156119be5760006118526060890189612fba565b8381811061186257611862612e9a565b905060e00201803603810190611878919061301b565b90508260ff16816060015160ff1610156118a557604051632f89717760e11b815260040160405180910390fd5b6118ae816124bb565b80516118ba90856130c6565b64ffffffffff8082166020808501918252606085015160078a018054600181810183556000928352939091208751600390920201805494518616600160281b0269ffffffffffffffffffff199095169190951617929092178084556040860151949850919650849391839160ff60501b1990911690600160501b90849081111561194657611946612ba4565b02179055506060820151815460808401516001600160a01b0316600160601b026bffffffffffffffffffffffff60ff909316600160581b02929092166affffffffffffffffffffff9091161717815560a0820151600182015560c09091015160029091015550806119b681612ec6565b91505061183b565b5060006119d16040880160208901612c3c565b90508064ffffffffff168364ffffffffff1611806119f757506109c464ffffffffff8416115b15611a15576040516340250f0160e11b815260040160405180910390fd5b611a2286886080016125a2565b83546001600160a01b03191633178455611a3f60208801886130eb565b8454600165ffffffffff0160a81b0316600160a81b911515919091026001600160d81b031617600160d81b64ffffffffff831602178455611a866060880160408901612c3c565b8460010160006101000a81548164ffffffffff021916908364ffffffffff160217905550611ab684876001612303565b5050505050919050565b611ac86120b1565b61120781612693565b611ad96120b1565b6001600160a01b038116611b3e5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610914565b61120781612412565b611b4f612462565b600254604051636eb1769f60e11b8152336004820152306024820152829160009182916001600160a01b03169063dd62ed3e90604401602060405180830381865afa158015611ba2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611bc69190613108565b905060005b838110156120205736868683818110611be657611be6612e9a565b90506040020190506005816020013510611c13576040516363df817160e01b815260040160405180910390fd5b80356000818152600460205260409020611c2e8160016121db565b600081600201846020013560058110611c4957611c49612e9a565b604080518082018252919092015464ffffffffff808216808452600160281b9092046001600160d01b031660208085019190915260008881526005825285812033825290915293842054929450611ca792600160d01b9004166130c6565b600184015490915064ffffffffff9081169082161115611cda5760405163d085f16160e01b815260040160405180910390fd5b60008481526005602090815260408083203384528252909120805464ffffffffff60d01b1916600160d01b64ffffffffff851602179055820151611d1e818a613121565b9850611d5c6040518060400160405280601181526020017065787065637465645553445456616c756560781b8152508a6001600160d01b0316612708565b611d8d6040518060400160405280600f81526020016e757365725553445442616c616e636560881b81525089612708565b87896001600160d01b03161115611de0576040805180820182526014815273496e73756666696369656e742062616c616e636560601b6020820152905162461bcd60e51b81526109149190600401613187565b6008840154600090808203611e04578451611dfd9060019061319a565b9150611e45565b845160088701611e15600184612f36565b81548110611e2557611e25612e9a565b600091825260209091200154611e42919064ffffffffff166130c6565b91505b8554600160a81b900460ff1615611e8957855464ffffffffff600160d81b909104811690831610611e89576040516334b3fb3b60e01b815260040160405180910390fd5b6040805180820190915264ffffffffff838116825233602080840191825260088a018054600180820183556000928352929091209451940180549251949093166001600160c81b031990921691909117600160281b6001600160a01b03909416840217909155870180548592600591611f0d918591046001600160d01b0316613121565b82546101009290920a6001600160d01b038181021990931691831602179091556000898152600560209081526040808320338452909152812080548794509092611f5991859116613121565b82546101009290920a6001600160d01b038181021990931691831602179091558651604080518b815233602082015264ffffffffff9092169082015290851660608201527fc25cd4cec0cbfb9bc40ad8f59ac733efcddf6ed3b7519369c9b9ceb2ee784601915060800160405180910390a18554611fe790600190600160d81b900464ffffffffff1661319a565b64ffffffffff168264ffffffffff161061200557612005878761274d565b5050505050505050808061201890612ec6565b915050611bcb565b506002546040516323b872dd60e01b81523360048201523060248201526001600160d01b03841660448201526001600160a01b03909116906323b872dd906064016020604051808303816000875af1158015612080573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120a49190612f9d565b5050505061092760018055565b6000546001600160a01b031633146112c35760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610914565b60008281526008602052604090205460ff16801561212a575081600954145b1561092757600082815260086020908152604080832060010154808452600490925290912060028154600160a01b900460ff16600581111561216e5761216e612ba4565b036121d55761217f81836003612303565b8260008151811061219257612192612e9a565b60200260200101516008600086815260200190815260200160002060000160016101000a8154816001600160f81b0302191690836001600160f81b031602179055505b50505050565b8060058111156121ed576121ed612ba4565b8254600160a01b900460ff16600581111561220a5761220a612ba4565b14610927576040516307a92f1960e51b815260040160405180910390fd5b336001600160a01b03821614611207576040516348f5c3ed60e01b815260040160405180910390fd5b60008251600003612264575060006122fd565b82516000905b808210156122b657600061227e83836128f9565b90508486828151811061229357612293612e9a565b602002602001015111156122a9578091506122b0565b8060010192505b5061226a565b6000821180156122e8575083856122ce600185612f36565b815181106122de576122de612e9a565b6020026020010151145b156122f957506000190190506122fd565b5090505b92915050565b82548190849060ff60a01b1916600160a01b83600581111561232757612327612ba4565b02179055507fc1191e7178b58ad510709587719f39ec315fa79e81ee7ba5c5ef3c894e94a651828260405161235d9291906131b8565b60405180910390a1505050565b60008164ffffffffff16116123b55760405162461bcd60e51b8152602060048201526011602482015270496e76616c69642066656520707269636560781b6044820152606401610914565b6007805464ffffffffff60a01b1916600160a01b64ffffffffff8416908102919091179091556040519081527f27b7f58ff9b5d7747c74d7d1bc186900d393741413f16db047f574afa1249820906020015b60405180910390a150565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6002600154036124b45760405162461bcd60e51b815260206004820152601f60248201527f5265656e7472616e637947756172643a207265656e7472616e742063616c6c006044820152606401610914565b6002600155565b6000816040015160018111156124d3576124d3612ba4565b03612516578060c0015160011415806124f85750806000015164ffffffffff16600114155b1561120757604051632f89717760e11b815260040160405180910390fd5b60018160400151600181111561252e5761252e612ba4565b036125705760808101516001600160a01b031660009081526006602052604090205460ff1661257057604051631eb3268560e31b815260040160405180910390fd5b60c081015115806124f85750805164ffffffffff1661120757604051632f89717760e11b815260040160405180910390fd5b60005b600581101561268e5760008282600581106125c2576125c2612e9a565b604002018036038101906125d691906131cc565b805160208201519192509064ffffffffff821615806125fc57506001600160d01b038116155b1561261957604051625cba9760e51b815260040160405180910390fd5b60008681526004602052604090208390600201856005811061263d5761263d612e9a565b8251910180546020909301516001600160d01b0316600160281b026001600160f81b031990931664ffffffffff9092169190911791909117905550829150612686905081612ec6565b9150506125a5565b505050565b6001600160a01b0381166126ba57604051630ed1b8b360e31b815260040160405180910390fd5b600780546001600160a01b0319166001600160a01b0383169081179091556040519081527f7a7b5a0a132f9e0581eb8527f66eae9ee89c2a3e79d4ac7e41a1f1f4d48a7fc290602001612407565b610927828260405160240161271e929190613235565b60408051601f198184030181529190526020810180516001600160e01b0316632d839cb360e21b17905261291b565b61275981836002612303565b805464ffffffffff60b01b1916600160b01b4264ffffffffff16021781556040516305d3b1d360e41b81527f0000000000000000000000000000000000000000000000000000000000000000600482015267ffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000166024820152600360448201526207a1206064820152600160848201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690635d3b1d309060a4016020604051808303816000875af1158015612847573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061286b9190613108565b600981905560008181526008602052604090205490915060ff16156128a357604051637c80909960e11b815260040160405180910390fd5b600081815260086020908152604091829020805460ff1916600190811782550185905581518581529081018390527f3d94fecedaa4f90b8bd459797adb95f5bb11426025c5541390d9ccc1ad1b60a1910161235d565b60006129086002848418613257565b61291490848416612f49565b9392505050565b6112078160006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b6040518060a001604052806005905b604080518082019091526000808252602082015281526020019060019003908161294f5790505090565b801515811461120757600080fd5b60008060006040848603121561299c57600080fd5b833567ffffffffffffffff808211156129b457600080fd5b818601915086601f8301126129c857600080fd5b8135818111156129d757600080fd5b8760208260051b85010111156129ec57600080fd5b60209283019550935050840135612a0281612979565b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715612a4c57612a4c612a0d565b604052919050565b60008060408385031215612a6757600080fd5b8235915060208084013567ffffffffffffffff80821115612a8757600080fd5b818601915086601f830112612a9b57600080fd5b813581811115612aad57612aad612a0d565b8060051b9150612abe848301612a23565b8181529183018401918481019089841115612ad857600080fd5b938501935b83851015612af657843582529385019390850190612add565b8096505050505050509250929050565b600060208284031215612b1857600080fd5b5035919050565b6101408101818360005b6005811015612b64578151805164ffffffffff1684526020908101516001600160d01b03168185015260409093019290910190600101612b29565b50505092915050565b80356001600160a01b0381168114612b8457600080fd5b919050565b600060208284031215612b9b57600080fd5b61291482612b6d565b634e487b7160e01b600052602160045260246000fd5b60068110612bca57612bca612ba4565b9052565b6001600160a01b038816815260e08101612beb6020830189612bba565b951515604082015264ffffffffff94851660608201529284166080840152921660a08201526001600160d01b0390911660c09091015292915050565b803564ffffffffff81168114612b8457600080fd5b600060208284031215612c4e57600080fd5b61291482612c27565b602080825282518282018190526000919060409081850190868401855b82811015612cc357815180516001600160a01b03168552868101511515878601528581015160ff168686015260609081015164ffffffffff169085015260809093019290850190600101612c74565b5091979650505050505050565b60008060408385031215612ce357600080fd5b82359150612cf360208401612b6d565b90509250929050565b602080825282518282018190526000919060409081850190868401855b82811015612cc3578151805164ffffffffff90811686528782015116878601528581015160028110612d4d57612d4d612ba4565b8587015260608181015160ff16908601526080808201516001600160a01b03169086015260a0808201519086015260c0908101519085015260e09093019290850190600101612d19565b602080825282518282018190526000919060409081850190868401855b82811015612cc3578151805164ffffffffff1685528601516001600160a01b0316868501529284019290850190600101612db4565b600060208284031215612dfb57600080fd5b813567ffffffffffffffff811115612e1257600080fd5b82016101c0818503121561291457600080fd5b60008060208385031215612e3857600080fd5b823567ffffffffffffffff80821115612e5057600080fd5b818501915085601f830112612e6457600080fd5b813581811115612e7357600080fd5b8660208260061b8501011115612e8857600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b600060018201612ed857612ed8612eb0565b5060010190565b6040808252810183905260008460608301825b86811015612f20576001600160a01b03612f0b84612b6d565b16825260209283019290910190600101612ef2565b5080925050508215156020830152949350505050565b818103818111156122fd576122fd612eb0565b808201808211156122fd576122fd612eb0565b634e487b7160e01b600052601260045260246000fd5b600082612f8157612f81612f5c565b500690565b80820281158282048414176122fd576122fd612eb0565b600060208284031215612faf57600080fd5b815161291481612979565b6000808335601e19843603018112612fd157600080fd5b83018035915067ffffffffffffffff821115612fec57600080fd5b602001915060e08102360382131561300357600080fd5b9250929050565b803560ff81168114612b8457600080fd5b600060e0828403121561302d57600080fd5b60405160e0810181811067ffffffffffffffff8211171561305057613050612a0d565b60405261305c83612c27565b815261306a60208401612c27565b602082015260408301356002811061308157600080fd5b60408201526130926060840161300a565b60608201526130a360808401612b6d565b608082015260a083013560a082015260c083013560c08201528091505092915050565b64ffffffffff8181168382160190808211156130e4576130e4612eb0565b5092915050565b6000602082840312156130fd57600080fd5b813561291481612979565b60006020828403121561311a57600080fd5b5051919050565b6001600160d01b038181168382160190808211156130e4576130e4612eb0565b6000815180845260005b818110156131675760208185018101518683018201520161314b565b506000602082860101526020601f19601f83011685010191505092915050565b6020815260006129146020830184613141565b64ffffffffff8281168282160390808211156130e4576130e4612eb0565b828152604081016129146020830184612bba565b6000604082840312156131de57600080fd5b6040516040810181811067ffffffffffffffff8211171561320157613201612a0d565b60405261320d83612c27565b815260208301356001600160d01b038116811461322957600080fd5b60208201529392505050565b6040815260006132486040830185613141565b90508260208301529392505050565b60008261326657613266612f5c565b50049056fea2646970667358221220900f7b50d9f92e6297861c0a8a472039416cb571dfc91d1d0c85ada92385530f64736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "claimFees(uint256)": {
        "params": {
          "raffleId": "The id of the raffle."
        }
      },
      "constructor": {
        "params": {
          "_feeRecipient": "The recipient of the fees",
          "_usdtInterface": "The USDT address"
        }
      },
      "createRaffle((bool,uint40,uint40,(uint40,uint40,uint8,uint8,address,uint256,uint256)[],(uint40,uint208)[5]))": {
        "params": {
          "params": "The parameters of the raffle."
        },
        "returns": {
          "raffleId": "The id of the newly created raffle."
        }
      },
      "enterRaffles((uint256,uint256)[])": {
        "params": {
          "entries": "The entries to be made."
        }
      },
      "getEntries(uint256)": {
        "params": {
          "raffleId": "The id of the raffle."
        },
        "returns": {
          "entries": "The entries entered for the raffle."
        }
      },
      "getPricingOptions(uint256)": {
        "params": {
          "raffleId": "The id of the raffle."
        },
        "returns": {
          "pricingOptions": "The pricing options for the raffle."
        }
      },
      "getPrizes(uint256)": {
        "params": {
          "raffleId": "The id of the raffle."
        },
        "returns": {
          "prizes": "The prizes to be distributed."
        }
      },
      "getWinners(uint256)": {
        "params": {
          "raffleId": "The id of the raffle."
        },
        "returns": {
          "winners": "The winners of the raffle."
        }
      },
      "getWinnersCount(uint256)": {
        "params": {
          "raffleId": "The id of the raffle."
        },
        "returns": {
          "winnersCount": "The count of winners."
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."
      },
      "selectWinners(uint256)": {
        "params": {
          "requestId": "The request id returned by Chainlink."
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "updateCurrenciesStatus(address[],bool)": {
        "details": "Only callable by owner.",
        "params": {
          "currencies": "Currency addresses (address(0) for ETH)",
          "isAllowed": "Whether the currencies should be allowed for trading"
        }
      }
    },
    "stateVariables": {
      "raffles": {
        "details": "The key is the raffle ID."
      },
      "randomnessRequests": {
        "details": "The key is the request ID returned by Chainlink."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "KEY_HASH()": {
        "notice": "The key hash of the Chainlink VRF."
      },
      "MAXIMUM_NUMBER_OF_PRIZES_PER_RAFFLE()": {
        "notice": "The maximum number of prizes per raffle.         Each individual ERC-721 counts as one prize.         Each ETH/ERC-20 with winnersCount > 1 counts as one prize."
      },
      "MAXIMUM_NUMBER_OF_WINNERS_PER_RAFFLE()": {
        "notice": "The maximum number of winners per raffle."
      },
      "PRICING_OPTIONS_PER_RAFFLE()": {
        "notice": "The number of pricing options per raffle."
      },
      "REQUEST_CONFIRMATIONS()": {
        "notice": "A Chainlink node should wait for 3 confirmations before responding."
      },
      "SUBSCRIPTION_ID()": {
        "notice": "The subscription ID of the Chainlink VRF."
      },
      "VRF_COORDINATOR()": {
        "notice": "The Chainlink VRF coordinator."
      },
      "claimFees(uint256)": {
        "notice": "Claims the fees collected for a raffle."
      },
      "createRaffle((bool,uint40,uint40,(uint40,uint40,uint8,uint8,address,uint256,uint256)[],(uint40,uint208)[5]))": {
        "notice": "Creates a new raffle."
      },
      "enterRaffles((uint256,uint256)[])": {
        "notice": "Enters a raffle or multiple raffles."
      },
      "feeRecipient()": {
        "notice": "The fee recipient."
      },
      "getEntries(uint256)": {
        "notice": "Gets the entries for a raffle."
      },
      "getPricingOptions(uint256)": {
        "notice": "Gets the pricing options for a raffle."
      },
      "getPrizes(uint256)": {
        "notice": "Gets the prizes for a raffle."
      },
      "getWinners(uint256)": {
        "notice": "Gets the winners for a raffle."
      },
      "getWinnersCount(uint256)": {
        "notice": "Get count of winners."
      },
      "isCurrencyAllowed(address)": {
        "notice": "It checks whether the currency is allowed."
      },
      "raffles(uint256)": {
        "notice": "The raffles created."
      },
      "rafflesCount()": {
        "notice": "The number of raffles created."
      },
      "randomnessRequests(uint256)": {
        "notice": "The randomness requests."
      },
      "selectWinners(uint256)": {
        "notice": "Select the winners for a raffle based on the random words returned by Chainlink."
      },
      "updateCurrenciesStatus(address[],bool)": {
        "notice": "This function allows the owner to update currency statuses."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3048,
        "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 3164,
        "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
        "label": "_status",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 1046,
        "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
        "label": "USDTInterface",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IERC20)2930"
      },
      {
        "astId": 1049,
        "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
        "label": "rafflesCount",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 1055,
        "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
        "label": "raffles",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_struct(Raffle)2611_storage)"
      },
      {
        "astId": 1062,
        "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
        "label": "rafflesParticipantsStats",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_uint256,t_mapping(t_address,t_struct(ParticipantStats)2619_storage))"
      },
      {
        "astId": 1067,
        "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
        "label": "isCurrencyAllowed",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 1081,
        "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
        "label": "feeRecipient",
        "offset": 0,
        "slot": "7",
        "type": "t_address"
      },
      {
        "astId": 1084,
        "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
        "label": "feePrice",
        "offset": 20,
        "slot": "7",
        "type": "t_uint40"
      },
      {
        "astId": 1108,
        "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
        "label": "randomnessRequests",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_uint256,t_struct(RandomnessRequest)2656_storage)"
      },
      {
        "astId": 1110,
        "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
        "label": "latestRequestId",
        "offset": 0,
        "slot": "9",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(Entry)2550_storage)dyn_storage": {
        "base": "t_struct(Entry)2550_storage",
        "encoding": "dynamic_array",
        "label": "struct IRaffleVRF.Entry[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(PricingOption)2544_storage)5_storage": {
        "base": "t_struct(PricingOption)2544_storage",
        "encoding": "inplace",
        "label": "struct IRaffleVRF.PricingOption[5]",
        "numberOfBytes": "160"
      },
      "t_array(t_struct(Prize)2577_storage)dyn_storage": {
        "base": "t_struct(Prize)2577_storage",
        "encoding": "dynamic_array",
        "label": "struct IRaffleVRF.Prize[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(Winner)2560_storage)dyn_storage": {
        "base": "t_struct(Winner)2560_storage",
        "encoding": "dynamic_array",
        "label": "struct IRaffleVRF.Winner[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(IERC20)2930": {
        "encoding": "inplace",
        "label": "contract IERC20",
        "numberOfBytes": "20"
      },
      "t_enum(RaffleStatus)2535": {
        "encoding": "inplace",
        "label": "enum IRaffleVRF.RaffleStatus",
        "numberOfBytes": "1"
      },
      "t_enum(TokenType)2538": {
        "encoding": "inplace",
        "label": "enum IRaffleVRF.TokenType",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_struct(ParticipantStats)2619_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct IRaffleVRF.ParticipantStats)",
        "numberOfBytes": "32",
        "value": "t_struct(ParticipantStats)2619_storage"
      },
      "t_mapping(t_uint256,t_mapping(t_address,t_struct(ParticipantStats)2619_storage))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(address => struct IRaffleVRF.ParticipantStats))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_struct(ParticipantStats)2619_storage)"
      },
      "t_mapping(t_uint256,t_struct(Raffle)2611_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IRaffleVRF.Raffle)",
        "numberOfBytes": "32",
        "value": "t_struct(Raffle)2611_storage"
      },
      "t_mapping(t_uint256,t_struct(RandomnessRequest)2656_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IRaffleVRF.RandomnessRequest)",
        "numberOfBytes": "32",
        "value": "t_struct(RandomnessRequest)2656_storage"
      },
      "t_struct(Entry)2550_storage": {
        "encoding": "inplace",
        "label": "struct IRaffleVRF.Entry",
        "members": [
          {
            "astId": 2547,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "currentEntryIndex",
            "offset": 0,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 2549,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "participant",
            "offset": 5,
            "slot": "0",
            "type": "t_address"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(ParticipantStats)2619_storage": {
        "encoding": "inplace",
        "label": "struct IRaffleVRF.ParticipantStats",
        "members": [
          {
            "astId": 2614,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "amountPaid",
            "offset": 0,
            "slot": "0",
            "type": "t_uint208"
          },
          {
            "astId": 2616,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "entriesCount",
            "offset": 26,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 2618,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "refunded",
            "offset": 31,
            "slot": "0",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(PricingOption)2544_storage": {
        "encoding": "inplace",
        "label": "struct IRaffleVRF.PricingOption",
        "members": [
          {
            "astId": 2541,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "entriesCount",
            "offset": 0,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 2543,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "price",
            "offset": 5,
            "slot": "0",
            "type": "t_uint208"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Prize)2577_storage": {
        "encoding": "inplace",
        "label": "struct IRaffleVRF.Prize",
        "members": [
          {
            "astId": 2563,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "winnersCount",
            "offset": 0,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 2565,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "cumulativeWinnersCount",
            "offset": 5,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 2568,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "prizeType",
            "offset": 10,
            "slot": "0",
            "type": "t_enum(TokenType)2538"
          },
          {
            "astId": 2570,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "prizeTier",
            "offset": 11,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 2572,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "prizeAddress",
            "offset": 12,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 2574,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "prizeId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 2576,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "prizeAmount",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(Raffle)2611_storage": {
        "encoding": "inplace",
        "label": "struct IRaffleVRF.Raffle",
        "members": [
          {
            "astId": 2580,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 2583,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "status",
            "offset": 20,
            "slot": "0",
            "type": "t_enum(RaffleStatus)2535"
          },
          {
            "astId": 2585,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "isMinimumEntriesFixed",
            "offset": 21,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 2587,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "drawnAt",
            "offset": 22,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 2589,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "minimumEntries",
            "offset": 27,
            "slot": "0",
            "type": "t_uint40"
          },
          {
            "astId": 2591,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "maximumEntriesPerParticipant",
            "offset": 0,
            "slot": "1",
            "type": "t_uint40"
          },
          {
            "astId": 2593,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "claimableFees",
            "offset": 5,
            "slot": "1",
            "type": "t_uint208"
          },
          {
            "astId": 2598,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "pricingOptions",
            "offset": 0,
            "slot": "2",
            "type": "t_array(t_struct(PricingOption)2544_storage)5_storage"
          },
          {
            "astId": 2602,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "prizes",
            "offset": 0,
            "slot": "7",
            "type": "t_array(t_struct(Prize)2577_storage)dyn_storage"
          },
          {
            "astId": 2606,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "entries",
            "offset": 0,
            "slot": "8",
            "type": "t_array(t_struct(Entry)2550_storage)dyn_storage"
          },
          {
            "astId": 2610,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "winners",
            "offset": 0,
            "slot": "9",
            "type": "t_array(t_struct(Winner)2560_storage)dyn_storage"
          }
        ],
        "numberOfBytes": "320"
      },
      "t_struct(RandomnessRequest)2656_storage": {
        "encoding": "inplace",
        "label": "struct IRaffleVRF.RandomnessRequest",
        "members": [
          {
            "astId": 2651,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "exists",
            "offset": 0,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 2653,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "randomWord",
            "offset": 1,
            "slot": "0",
            "type": "t_uint248"
          },
          {
            "astId": 2655,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "raffleId",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Winner)2560_storage": {
        "encoding": "inplace",
        "label": "struct IRaffleVRF.Winner",
        "members": [
          {
            "astId": 2553,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "participant",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 2555,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "claimed",
            "offset": 20,
            "slot": "0",
            "type": "t_bool"
          },
          {
            "astId": 2557,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "prizeIndex",
            "offset": 21,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 2559,
            "contract": "contracts/RaffleVRF.sol:RaffleWithVRF",
            "label": "entryIndex",
            "offset": 22,
            "slot": "0",
            "type": "t_uint40"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint208": {
        "encoding": "inplace",
        "label": "uint208",
        "numberOfBytes": "26"
      },
      "t_uint248": {
        "encoding": "inplace",
        "label": "uint248",
        "numberOfBytes": "31"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint40": {
        "encoding": "inplace",
        "label": "uint40",
        "numberOfBytes": "5"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}